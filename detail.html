<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Detail</title>
  <link rel="icon" href="data:,">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="" />
  <style>
    body { font-family: system-ui,-apple-system,Segoe UI,Roboto; max-width: 920px; margin: 20px auto; padding: 0 12px; color:#111827; }
    .btn { padding:6px 10px; border:1px solid #e5e7eb; border-radius:8px; background:#fff; cursor:pointer; }
    .card { border:1px solid #e5e7eb; border-radius:10px; padding:10px 12px; margin:10px 0; background:#fff; }
    #map { height: 40vh; border:1px solid #e5e7eb; border-radius:10px; }
    .muted{ color:#6b7280; }
    .elev-card { margin-top:12px; border:1px solid #e5e7eb; border-radius:10px; padding:10px 12px; background:#fff; display:none; }
    #elevChart { width:100%; height:140px; display:block; margin-top:8px; }
    .detail-meta-title { display:flex; align-items:baseline; gap:8px; flex-wrap:wrap; }
    .detail-edit-link { text-decoration:none; font-size:16px; line-height:1; }
    .detail-edit-link:visited { color:inherit; }
    .detail-kind { font-size:12px; padding:2px 8px; border-radius:999px; border:1px solid #e5e7eb; background:#f9fafb; }
    .detail-meta-lines { margin-top:4px; display:flex; flex-direction:column; gap:2px; }
    .photo-box { margin-top:12px; border:1px solid #e5e7eb; border-radius:10px; padding:10px 12px; background:#fff; display:none; }
    .photo-box-header { display:flex; align-items:center; justify-content:space-between; gap:8px; }
    .photo-manage-link { color:#111827; text-decoration:underline; font-weight:600; }
    .photo-list { display:flex; gap:8px; flex-wrap:wrap; margin-top:8px; align-items:center; }
    .photo-thumb { width:54px; height:54px; object-fit:cover; border-radius:6px; border:1px solid #e5e7eb; display:block; }
    .photo-pin-icon { background: transparent; border: none; }
    .photo-pin {
      width: 26px;
      height: 26px;
      background: #1a73e8;
      border-radius: 50% 50% 50% 0;
      transform: rotate(-45deg);
      position: relative;
      box-shadow: 0 2px 6px rgba(17, 24, 39, 0.35);
      border: 2px solid #fff;
    }
    .photo-pin__inner {
      width: 8px;
      height: 8px;
      background: #fff;
      border-radius: 50%;
      position: absolute;
      top: 7px;
      left: 7px;
      transform: rotate(45deg);
    }

/* --- 描画モード：地図を実質フルスクリーン化 --- */
body.mode-draw #map { height: calc(var(--vh, 1vh) * 100); }

/* 描画ツールバー（パレット） */
.draw-toolbar{
  position: fixed;
  left: 50%;
  transform: translateX(-50%);
  top: 10px;
  display: flex; gap: 8px; flex-wrap: wrap;
  background: rgba(255,255,255,.96);
  border: 1px solid #e5e7eb; border-radius: 12px;
  padding: 8px 10px;
  box-shadow: 0 2px 12px rgba(0,0,0,.1);
  z-index: 5000;
}
.draw-toolbar .btn { padding:8px 12px; border-radius:10px; }

/* スマホ最適化 */
@media (max-width: 600px) {
  .draw-toolbar{ top: 8px; padding: 10px 12px; }
  .draw-toolbar .btn{ padding: 10px 14px; }
}

/* 既存：閲覧/記録モードの高さ基準（そのまま利用） */
#map { height: 33vh; transition: height .2s ease; }
@media (max-width: 600px) { #map{ height: 30vh; } }
body.mode-record #map { height: calc(var(--vh, 1vh) * 90); }

.rec-overlay {
  position: fixed;
  left: 50%;
  transform: translateX(-50%);
  bottom: 12px;
  display: none; gap: 8px;
  background: rgba(255,255,255,.92);
  border: 1px solid #e5e7eb; border-radius: 12px;
  padding: 8px 10px;
  box-shadow: 0 2px 12px rgba(0,0,0,.08);
  z-index: 5000;
}
.rec-overlay .stat { font-size: 12px; color: #374151; }
.rec-overlay .stat strong { font-size: 14px; }
@media (max-width: 600px) {
  .rec-overlay { bottom: 10px; padding: 10px 12px; }
  .rec-overlay .btn { padding: 10px 14px; border-radius: 12px; }
}

</style>

<script src="js/version.js"></script>

<script>
  const COLORS = {
    routePlanned: '#3b82f6', // 青
    runRecorded:  '#10b981', // 履歴Run表示（緑）
    liveOnRoute:  '#10b981', // 実走オンルート：緑
    liveOffRoute: '#ef4444'  // 実走逸脱：赤
  };
</script>

<script>
  // 1) バージョン管理：変わったらSWもCacheも全消し → 強制再読込
  async function hardRefreshIfVersionChanged() {
    try {
      const v = String(window.APP_VERSION || '');
      const prev = localStorage.getItem('APP_VERSION');
      if (prev && prev !== v) {
        // 既存SWを全部解除
        if ('serviceWorker' in navigator) {
          const regs = await navigator.serviceWorker.getRegistrations();
          await Promise.all(regs.map(r => r.unregister()));
        }
        // 既存Cacheを全削除
        if (window.caches?.keys) {
          const keys = await caches.keys();
          await Promise.all(keys.map(k => caches.delete(k)));
        }
        localStorage.setItem('APP_VERSION', v);
        // ハードリロード
        location.replace(location.pathname + '?v=' + encodeURIComponent(v) + '&t=' + Date.now());
        return;
      }
      localStorage.setItem('APP_VERSION', v);
    } catch (e) { console.warn('hardRefreshIfVersionChanged', e); }
  }

  // 2) すぐ実行（SW登録より先に）
  hardRefreshIfVersionChanged();
</script>
<script>
    if (typeof window.APP_VERSION === 'undefined' || !window.APP_VERSION) {
      window.APP_VERSION = new Date().toISOString().slice(0,10) + '-dev';
    }
    window.APP_VERSION = String(window.APP_VERSION) + '-detailfix4';
  </script>

  <script src="https://unpkg.com/@supabase/supabase-js@2/dist/umd/supabase.js"></script>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
  <script>
    const SUPABASE_URL = "https://cqiqhczxuiyakptdjowr.supabase.co";
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNxaXFoY3p4dWl5YWtwdGRqb3dyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTc3NzAwNzMsImV4cCI6MjA3MzM0NjA3M30.vCFQoQnsClINKa5tQAz-rNnF5XLEukmn_Nl0Err5k3k";
    const client = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY, { auth:{ persistSession:true, autoRefreshToken:true, detectSessionInUrl:false } });
    window.client = client; // デバッグ用に公開

    const V = ()=> encodeURIComponent(window.APP_VERSION||'');
    const $ = (s)=> document.querySelector(s);
    const q = new URL(location.href).searchParams;
    const id = Number(q.get('id'));
    const kind = q.get('kind') || 'run';
    let __map;
    let __currentRoute = null;
    let __photoPinLayer = null;

    async function getSession(){ const { data:{ session } } = await client.auth.getSession(); return session; }
    async function getMyAccountId(){
      return AuthCommon.getMyAccountId(client);
    }

    function decodePolyline(str){ try{ let idx=0, lat=0, lng=0, arr=[]; while(idx<str.length){ let b,shift=0,result=0; do{ b=str.charCodeAt(idx++)-63; result|=(b&0x1f)<<shift; shift+=5; }while(b>=0x20); let dlat=(result&1)?~(result>>1):(result>>1); shift=0; result=0; do{ b=str.charCodeAt(idx++)-63; result|=(b&0x1f)<<shift; shift+=5; }while(b>=0x20); let dlng=(result&1)?~(result>>1):(result>>1); lat+=dlat; lng+=dlng; arr.push([lat/1e5,lng/1e5]); } return arr; }catch(e){ console.error('decodePolyline', e); return []; } }
    function normalizePoints(points){
      if (!Array.isArray(points)) return [];
      const out = [];
      for (const p of points) {
        if (!p) continue;
        if (Array.isArray(p)) {
          const a = Number(p[0]);
          const b = Number(p[1]);
          if (!Number.isFinite(a) || !Number.isFinite(b)) continue;
          if (Math.abs(a) > 90 && Math.abs(b) <= 90) out.push({ lat: b, lng: a });
          else out.push({ lat: a, lng: b });
          continue;
        }
        const lat = Number(p.lat ?? p.latitude);
        const lng = Number(p.lng ?? p.lon ?? p.longitude);
        if (!Number.isFinite(lat) || !Number.isFinite(lng)) continue;
        out.push({ lat, lng });
      }
      return out;
    }
    function parseGeojsonMaybeTwice(input){
      if (input == null) return null;
      if (typeof input !== 'string') return input;
      try{
        let parsed = JSON.parse(input);
        if (typeof parsed === 'string') parsed = JSON.parse(parsed);
        return parsed;
      }catch(e){
        console.warn('parseGeojsonMaybeTwice', e);
        return null;
      }
    }
    function extractLatLngsFromRoute(route){
      try{
        if (Array.isArray(route?.points)) {
          const pts = normalizePoints(route.points);
          if (pts.length) return pts;
        }
        if (route?.geojson){
          const g = parseGeojsonMaybeTwice(route.geojson);
          if (!g) return [];
          const out = [];
          const walk = (geom)=>{
            if(!geom) return;
            const t = geom.type;
            const co = geom.coordinates;
            if (t==='LineString'){
              co.forEach(([lng,lat])=> out.push({lat,lng}));
            } else if (t==='MultiLineString'){
              co.forEach(line=> line.forEach(([lng,lat])=> out.push({lat,lng})));
            } else if (t==='GeometryCollection'){
              (geom.geometries||[]).forEach(walk);
            }
          };
          if (g.type==='Feature') walk(g.geometry);
          else if (g.type==='FeatureCollection') (g.features||[]).forEach(f=> walk(f.geometry));
          else walk(g);
          if (out.length) return out;
        }
      }catch(e){ console.warn('extract geojson', e); }
      if (route?.polyline){
        return decodePolyline(route.polyline).map(([lat,lng])=>({lat,lng}));
      }
      if (Array.isArray(route?.points)) {
        const pts = normalizePoints(route.points);
        if (pts.length) return pts;
      }
      return [];
    }
    function distancePointToSegmentMeters(p, a, b){
      const latFactor = 111320;
      const lonFactor = 111320 * Math.cos(((a.lat + b.lat) / 2) * Math.PI / 180);
      const ax = a.lng * lonFactor, ay = a.lat * latFactor;
      const bx = b.lng * lonFactor, by = b.lat * latFactor;
      const px = p.lng * lonFactor, py = p.lat * latFactor;
      const vx = bx - ax, vy = by - ay;
      const wx = px - ax, wy = py - ay;
      const c1 = vx * wx + vy * wy;
      const c2 = vx * vx + vy * vy;
      let t = c2 > 0 ? (c1 / c2) : 0;
      t = Math.max(0, Math.min(1, t));
      const sx = ax + t * vx, sy = ay + t * vy;
      const dx = px - sx, dy = py - sy;
      return Math.sqrt(dx * dx + dy * dy);
    }
    function distancePointToPolylineMeters(p, line){
      if (!line || line.length < 2) return Infinity;
      let best = Infinity;
      for (let i = 1; i < line.length; i++){
        const d = distancePointToSegmentMeters(p, line[i-1], line[i]);
        if (d < best) best = d;
      }
      return best;
    }

    const distanceOnEarth = (a, b) => {
      const R = 6371000;
      const toRad = (x) => x * Math.PI / 180;
      const dLat = toRad(b.lat - a.lat);
      const dLng = toRad(b.lng - a.lng);
      const lat1 = toRad(a.lat);
      const lat2 = toRad(b.lat);
      const s = Math.sin(dLat / 2) ** 2 + Math.cos(lat1) * Math.cos(lat2) * Math.sin(dLng / 2) ** 2;
      return 2 * R * Math.asin(Math.sqrt(s));
    };

    function fmtSbError(err){
      return err?.message || String(err || '不明なエラー');
    }

    function fmtKmText(m){
      return m == null ? '-' : (Number(m) / 1000).toFixed(2) + ' km';
    }
    function fmtMinText(s){
      return s == null ? '-' : Math.round(Number(s) / 60) + ' 分';
    }

    function renderDetailMeta(kindLabel, idValue, title, when, distanceText, durationText, extraHtml){
      const box = $('#meta');
      if (!box) return;
      const extra = extraHtml || '';
      const editLink = (kindLabel === 'ルート' && idValue)
        ? `<a class="detail-edit-link" href="detail-edit.html?id=${encodeURIComponent(idValue)}&v=${V()}" aria-label="編集">✏️</a>`
        : '';
      box.innerHTML = `
        <div class="detail-meta-title">
          <span class="detail-kind">${kindLabel}</span>
          <div style="font-weight:600;">${title}</div>
          ${editLink}
          <span class="muted">#${idValue}</span>
        </div>
        <div class="detail-meta-lines">
          <div class="muted">日時: ${when || '-'}</div>
          <div class="muted">距離: ${distanceText || '-'} ・ 時間: ${durationText || '-'}</div>
          ${extra}
        </div>
      `;
    }

    function closestByTime(items, timeKey, targetTimeMs){
      if (!Array.isArray(items) || !Number.isFinite(targetTimeMs)) return null;
      let best = null;
      let bestDiff = Infinity;
      for (const item of items) {
        const t = item?.[timeKey];
        if (!t) continue;
        const ms = new Date(t).getTime();
        if (!Number.isFinite(ms)) continue;
        const diff = Math.abs(ms - targetTimeMs);
        if (diff < bestDiff) {
          bestDiff = diff;
          best = item;
        }
      }
      return best ? { item: best, diffMs: bestDiff } : null;
    }

    async function resolveRouteForRun(runRow){
      if (!runRow?.account_id) return null;
      const targetMs = new Date(runRow.started_at || runRow.created_at || runRow.ended_at || Date.now()).getTime();
      try{
        const { data, error } = await client
          .from('routes')
          .select('id,created_at,account_id,route_type')
          .eq('account_id', runRow.account_id)
          .eq('route_type', 'from_run')
          .order('created_at', { ascending: false })
          .limit(10);
        if (error || !data) return null;
        const best = closestByTime(data, 'created_at', targetMs);
        if (!best) return null;
        const withinMs = 6 * 60 * 60 * 1000;
        return best.diffMs <= withinMs ? best.item : null;
      }catch(e){
        console.warn('resolveRouteForRun failed', e);
        return null;
      }
    }

    async function resolveRunForRoute(routeRow){
      if (!routeRow?.account_id) return null;
      const targetMs = new Date(routeRow.created_at || Date.now()).getTime();
      try{
        const { data, error } = await client
          .from('runs')
          .select('id,created_at,started_at,ended_at,polyline,geojson,distance_m,duration_s')
          .eq('account_id', routeRow.account_id)
          .order('created_at', { ascending: false })
          .limit(10);
        if (error || !data) return null;
        const best = closestByTime(data, 'created_at', targetMs);
        if (!best) return null;
        const withinMs = 6 * 60 * 60 * 1000;
        return best.diffMs <= withinMs ? best.item : null;
      }catch(e){
        console.warn('resolveRunForRoute failed', e);
        return null;
      }
    }

    const totalDistanceMeters = (points) => {
      if (!Array.isArray(points) || points.length < 2) return 0;
      let sum = 0;
      for (let i = 1; i < points.length; i++) {
        sum += distanceOnEarth(points[i - 1], points[i]);
      }
      return sum;
    };

    const cumDistances = (points) => {
      const out = [0];
      for (let i = 1; i < points.length; i++) {
        out[i] = out[i - 1] + distanceOnEarth(points[i - 1], points[i]);
      }
      return out;
    };

    const samplePoints = (points, maxN = 200) => {
      if (!Array.isArray(points) || points.length === 0) return [];
      if (points.length <= maxN) return points.slice();
      const step = Math.ceil(points.length / maxN);
      const res = [];
      for (let i = 0; i < points.length; i += step) {
        res.push(points[i]);
      }
      if (res[res.length - 1] !== points[points.length - 1]) {
        res.push(points[points.length - 1]);
      }
      return res;
    };

    async function fetchElevations(points) {
      try {
        const samples = samplePoints(points, 200);
        if (!samples.length) return null;
        const qs = samples.map((p) => `${p.lat},${p.lng}`).join('|');
        const url = `https://api.open-elevation.com/api/v1/lookup?locations=${encodeURIComponent(qs)}`;
        const res = await fetch(url, { mode: 'cors' });
        if (!res.ok) return null;
        const json = await res.json();
        const list = json?.results?.map((r) => r.elevation).filter((v) => Number.isFinite(v));
        if (!list || list.length < 2) return null;
        if (points.length <= list.length) return list.slice(0, points.length);
        const expanded = new Array(points.length);
        const step = (points.length - 1) / (list.length - 1);
        for (let i = 0; i < points.length; i++) {
          const pos = i / step;
          const k = Math.floor(pos);
          if (k >= list.length - 1) {
            expanded[i] = list[list.length - 1];
            continue;
          }
          const t = pos - k;
          expanded[i] = list[k] * (1 - t) + list[k + 1] * t;
        }
        return expanded;
      } catch (err) {
        console.warn('fetchElevations failed', err);
        return null;
      }
    }

    const sumGainLoss = (elevs, threshold = 2) => {
      let up = 0;
      let down = 0;
      for (let i = 1; i < elevs.length; i++) {
        const diff = elevs[i] - elevs[i - 1];
        if (diff > threshold) up += diff;
        else if (diff < -threshold) down += -diff;
      }
      return { up: Math.round(up), down: Math.round(down) };
    };

    const smoothElevations = (values, windowSize = 5) => {
      if (!Array.isArray(values) || values.length < 2) return values || [];
      const size = Math.max(1, Math.floor(windowSize));
      if (size <= 1) return values.slice();
      const half = Math.floor(size / 2);
      const smoothed = new Array(values.length);
      for (let i = 0; i < values.length; i++) {
        const start = Math.max(0, i - half);
        const end = Math.min(values.length - 1, i + half);
        let sum = 0;
        let count = 0;
        for (let j = start; j <= end; j++) {
          sum += values[j];
          count++;
        }
        smoothed[i] = count ? sum / count : values[i];
      }
      return smoothed;
    };

    const drawElevationProfile = (svg, elevs, points, opts = {}) => {
      if (!svg) return;
      const ns = 'http://www.w3.org/2000/svg';
      const width = svg.clientWidth || 600;
      const height = svg.clientHeight || 140;
      svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
      while (svg.firstChild) svg.removeChild(svg.firstChild);

      const dists = cumDistances(points);
      const total = dists[dists.length - 1] || 1;
      const marginRatio = opts.marginRatio ?? 0.15;
      const topPad = opts.topPad ?? 6;
      const bottomPad = opts.bottomPad ?? 8;
      const plotHeight = Math.max(1, height - topPad - bottomPad);
      const yBase = topPad + plotHeight;
      const minAxis = 0;
      const maxAxis = Math.max(...elevs, 0);
      const margin = Math.max(1, maxAxis * marginRatio);
      const maxWithMargin = maxAxis + margin;
      const axisRange = Math.max(1, maxWithMargin - minAxis);

      const x = (i) => (width * (dists[i] / total));
      const y = (e) => {
        const clamped = Math.max(minAxis, Math.min(maxWithMargin, e));
        return yBase - ((clamped - minAxis) / axisRange) * plotHeight;
      };

      const pathArea = document.createElementNS(ns, 'path');
      let d = `M 0 ${yBase}`;
      for (let i = 0; i < elevs.length; i++) {
        d += ` L ${x(i).toFixed(2)} ${y(elevs[i]).toFixed(2)}`;
      }
      d += ` L ${width} ${yBase} Z`;
      pathArea.setAttribute('d', d);
      pathArea.setAttribute('fill', '#86efac');
      pathArea.setAttribute('stroke', '#15803d');
      pathArea.setAttribute('stroke-width', '1.5');
      svg.appendChild(pathArea);

      const ticks = 4;
      for (let i = 0; i <= ticks; i++) {
        const val = minAxis + ((axisRange) * i) / ticks;
        const yy = y(val);
        const line = document.createElementNS(ns, 'line');
        line.setAttribute('x1', 0);
        line.setAttribute('x2', width);
        line.setAttribute('y1', yy);
        line.setAttribute('y2', yy);
        line.setAttribute('stroke', '#f3f4f6');
        svg.appendChild(line);

        const label = document.createElementNS(ns, 'text');
        label.setAttribute('x', 4);
        label.setAttribute('y', Math.max(10, yy - 4));
        label.setAttribute('fill', '#6b7280');
        label.setAttribute('font-size', '10');
        label.textContent = `${Math.round(val)} m`;
        svg.appendChild(label);
      }
    };

    async function renderElevationPanel(points){
      const box = document.getElementById('elevBox');
      const statsEl = document.getElementById('elevStats');
      const chartEl = document.getElementById('elevChart');
      if (!box || !statsEl || !chartEl) return;
      if (!Array.isArray(points) || points.length < 2) {
        box.style.display = 'none';
        return;
      }
      box.style.display = 'block';
      statsEl.textContent = '標高データ取得中…';
      chartEl.innerHTML = '';

      const rawElevs = await fetchElevations(points);
      if (!rawElevs || rawElevs.length < 2) {
        statsEl.textContent = '標高データを取得できませんでした。';
        chartEl.innerHTML = '';
        return;
      }
      const elevs = smoothElevations(rawElevs, rawElevs.length < 7 ? 3 : 5); // 軽い移動平均でギザギザを抑える
      const minElev = Math.min(...elevs);

      const totalDist = totalDistanceMeters(points);
      const { up, down } = sumGainLoss(elevs, 2);
      const netGain = elevs[elevs.length - 1] - elevs[0];
      const avgGrade = totalDist > 0 ? ((netGain / totalDist) * 100) : 0;
      statsEl.textContent = `総上昇 ${up} m ／ 総下降 ${down} m ／ 平均勾配 ${avgGrade.toFixed(1)} %`;
      drawElevationProfile(chartEl, elevs, points, { marginRatio: 0.15 });
    }

    function ensurePhotoPinLayer(){
      if (!__map) return null;
      if (!__photoPinLayer) __photoPinLayer = L.layerGroup().addTo(__map);
      return __photoPinLayer;
    }

    function fitMapToPoints(points){
      if (!__map || !Array.isArray(points) || points.length === 0) return;
      try{
        if (points.length === 1) {
          __map.setView(points[0], 16);
        } else {
          const bounds = L.latLngBounds(points);
          __map.fitBounds(bounds, { padding:[20,20], maxZoom:16 });
        }
      }catch(e){ console.warn('fitMapToPoints', e); }
    }

    async function loadRoutePhotos(routeId){
      const photoBox = document.getElementById('photoBox');
      const photoStatus = document.getElementById('photoStatus');
      const photoList = document.getElementById('photoList');
      const photoManage = document.getElementById('lnPhotoManage');
      if (!photoBox || !photoStatus || !photoList) return;

      if (!routeId) {
        photoBox.style.display = 'none';
        if (photoManage) photoManage.removeAttribute('href');
        if (__photoPinLayer) __photoPinLayer.clearLayers();
        return [];
      }

      photoBox.style.display = 'block';
      photoStatus.textContent = '写真読み込み中…';
      photoList.innerHTML = '';

      let orderCol = 'taken_at';
      let data = null;
      let error = null;
      try {
        ({ data, error } = await client
          .from('route_spot_photos')
          .select('id, image_url, thumb_url, taken_at, lat, lng')
          .eq('route_id', routeId)
          .order(orderCol, { ascending: false }));
      } catch (e) {
        error = e;
      }

      if (error && String(error?.message || '').includes('column')) {
        orderCol = 'created_at';
        try {
          ({ data, error } = await client
            .from('route_spot_photos')
            .select('id, image_url, thumb_url, lat, lng')
            .eq('route_id', routeId)
            .order(orderCol, { ascending: false }));
        } catch (e) {
          error = e;
        }
      }

      if (error) {
        console.error('route_spot_photos list error', error);
        photoStatus.textContent = `写真取得失敗: ${fmtSbError(error)}`;
        if (__photoPinLayer) __photoPinLayer.clearLayers();
        return [];
      }

      if (!data || data.length === 0) {
        photoStatus.textContent = '写真なし';
        if (__photoPinLayer) __photoPinLayer.clearLayers();
        return [];
      }

      const limit = 5;
      const show = data.slice(0, limit);
      photoStatus.textContent = data.length > limit
        ? `最新${show.length}枚（全${data.length}枚）`
        : `${data.length}枚`;

      const urlBase = `route-photos.html?route_id=${encodeURIComponent(routeId)}&v=${V()}`;
      if (photoManage) {
        photoManage.href = `detail-edit.html?id=${encodeURIComponent(routeId)}&v=${V()}`;
      }
      const thumbsHtml = show.map((row) => {
        const url = `${urlBase}&focus_photo_id=${encodeURIComponent(row.id)}`;
        const thumbSrc = row.thumb_url || row.image_url;
        return `<a href="${url}"><img class="photo-thumb" src="${thumbSrc}" alt="route photo" /></a>`;
      }).join('');
      const hasMore = data.length > show.length;
      const moreHtml = hasMore
        ? `<span style="display:inline-block; color:#6b7280; font-weight:600;">…</span>`
        : '';
      const listLink = `<a href="${urlBase}" style="color:#111827; text-decoration:underline; font-weight:600;">画像一覧</a>`;
      photoList.innerHTML = `${thumbsHtml}${moreHtml}${listLink}`;

      const pinLayer = ensurePhotoPinLayer();
      if (!pinLayer) return;
      pinLayer.clearLayers();
      const icon = L.divIcon({
        className: 'photo-pin-icon',
        html: '<div class="photo-pin"><div class="photo-pin__inner"></div></div>',
        iconSize: [26, 26],
        iconAnchor: [13, 26],
        popupAnchor: [0, -24],
      });
      const points = [];
      for (const row of data) {
        const lat = Number(row.lat);
        const lng = Number(row.lng);
        if (!Number.isFinite(lat) || !Number.isFinite(lng)) continue;
        points.push({ lat, lng });
        const when = row.taken_at ? new Date(row.taken_at).toLocaleString() : '撮影時刻不明';
        const url = `${urlBase}&focus_photo_id=${encodeURIComponent(row.id)}`;
        const marker = L.marker([lat, lng], { icon });
        marker.bindPopup(`
          <div style="min-width:160px;">
            <div style="font-size:12px; color:#4b5563;">${when}</div>
            <a href="${url}" style="font-weight:600; color:#111827; text-decoration:underline;">写真を見る</a>
          </div>
        `);
        pinLayer.addLayer(marker);
      }
      return points;
    }

    async function resolvePhotoRouteIdForRun(runId){
      try{
        const { data, error } = await client
          .from('routes')
          .select('id')
          .eq('source_run_id', runId)
          .order('id', { ascending: false })
          .limit(1)
          .maybeSingle();
        if (error) return null;
        return data?.id || null;
      }catch(e){
        return null;
      }
    }

    async function renderAuthBar(){
      const bar = $('#authBar');
      try{
        const s = await getSession();
        if(!s?.user){
          bar.innerHTML = `未ログインです。<a class="btn" href="login.html?v=${V()}">ログインへ</a>`;
          return;
        }
        const email = s.user.email || '';
        bar.innerHTML = `
          ログイン中: <strong>${email}</strong>
          <button class="btn" data-signout style="margin-left:8px">サインアウト</button>
          <a class="btn" style="margin-left:6px" href="mypage.html?v=${V()}">マイページへ</a>
          <a class="btn" style="margin-left:6px" href="index.html?v=${V()}">トップへ</a>
        `;
      }catch(e){ bar.textContent='認証状態の取得に失敗しました'; console.error(e); }
    }

    async function loadRun(){
      const box = $('#meta'); const btn = $('#btnToRoute');
      try{
        const { data: run, error } = await client.from('runs').select('id,name,started_at,ended_at,distance_m,duration_s,polyline,geojson,account_id').eq('id', id).maybeSingle();
        if(error || !run){ box.textContent='読み込み失敗'; console.error(error); return; }
        const when = run.ended_at ? new Date(run.ended_at).toLocaleString() : (run.started_at ? new Date(run.started_at).toLocaleString() : '-');
        const title = run.name || '実走ログ';
        const extra = run.started_at
          ? `<div class="muted">開始: ${new Date(run.started_at).toLocaleString()}</div>`
          : '';
        renderDetailMeta('ログ', run.id, title, when, fmtKmText(run.distance_m), fmtMinText(run.duration_s), extra);
        const mapEl = document.getElementById('map');
        if (__map) {
          __map.remove();
          __map = undefined;
        }
        __photoPinLayer = null;
        if (mapEl && mapEl._leaflet_id) {
          mapEl._leaflet_id = null;
          mapEl.innerHTML = '';
        }
        __map = L.map('map').setView([35.68,139.76], 12);
        L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png',{ maxZoom:19, attribution:'&copy; OpenStreetMap' }).addTo(__map);
        const runPoints = extractLatLngsFromRoute(run);
        let runLayer = drawLineOnMap(__map, run.polyline, run.geojson, COLORS.runRecorded);
        if ((!runLayer || (runLayer.getBounds && !runLayer.getBounds().isValid())) && runPoints.length >= 2) {
          runLayer = L.polyline(runPoints, { color: COLORS.runRecorded, weight:5 }).addTo(__map);
        }
        if (runPoints.length >= 1) fitMapToPoints(runPoints);
        await renderElevationPanel(runPoints);
        let photoRouteId = await resolvePhotoRouteIdForRun(run.id);
        if (!photoRouteId) {
          const fallbackRoute = await resolveRouteForRun(run);
          photoRouteId = fallbackRoute?.id || null;
        }
        const photoPoints = await loadRoutePhotos(photoRouteId);
        if (runPoints.length < 2 && photoPoints.length >= 1) fitMapToPoints(photoPoints);

        // ルート化ボタン
        btn.style.display='inline-block';
        btn.onclick = async ()=>{
          try{
            const acc = await getMyAccountId(); if(!acc){ alert('ログインが必要です'); return; }
            const ymd = (d=> `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`)(new Date(run.ended_at||run.started_at||Date.now()));
            const payload = { name: `Run ${ymd} のルート`, account_id: acc, is_public: false, route_type: 'from_run', source_run_id: run.id, polyline: run.polyline ?? null, geojson: run.geojson ?? null };
            const { data:newRow, error:e2 } = await client.from('routes').insert([payload]).select('id').maybeSingle();
            if(e2 || !newRow){
              console.error('ROUTE FROM RUN INSERT ERROR', e2, payload);
              alert('作成に失敗: ' + (e2?.message || '不明なエラー'));
              return;
            }
            location.href = `detail.html?id=${encodeURIComponent(newRow.id)}&kind=route&v=${V()}`;
          }catch(e){ console.error(e); alert('作成に失敗'); }
        };
      }catch(e){ box.textContent='読み込み失敗'; console.error(e); }
    }

    async function loadRoute(){
      const box = $('#meta'); const toggleWrap = $('#toggleWrap'); const toggle = $('#visToggle');
      let routeRow = null;
      try{
        const { data, error } = await client.from('routes')
          .select('*')
          .eq('id', id).maybeSingle();
        routeRow = data;
        if(error || !routeRow){ box.textContent='読み込み失敗'; console.error(error); return; }
        __currentRoute = routeRow;
        const when = routeRow.created_at ? new Date(routeRow.created_at).toLocaleString() : '-';
        const title = routeRow.name || 'ルート';
        const typeLabel = routeRow.route_type === 'from_run' ? 'ログ由来' : (routeRow.route_type || '-');
        const pubLabel = routeRow.is_public ? '公開' : '非公開';
        const owner = routeRow.account_id || '-';
        const extraParts = [];
        if (routeRow.description) extraParts.push(`<div class="muted">説明: ${routeRow.description}</div>`);
        extraParts.push(`<div class="muted">種別: ${typeLabel} ・ 公開: ${pubLabel}</div>`);
        extraParts.push(`<div class="muted">Owner Account: ${owner}</div>`);
        if (routeRow.source_run_id) {
          extraParts.push(
            `<div class="muted">元ログ: <a class="btn" href="detail.html?id=${encodeURIComponent(routeRow.source_run_id)}&kind=run&v=${V()}">Run #${routeRow.source_run_id}</a></div>`
          );
        }
        renderDetailMeta('ルート', routeRow.id, title, when, fmtKmText(routeRow.distance_m), fmtMinText(routeRow.duration_s), extraParts.join(''));
        const mapEl = document.getElementById('map');
        if (__map) {
          __map.remove();
          __map = undefined;
        }
        __photoPinLayer = null;
        if (mapEl && mapEl._leaflet_id) {
          mapEl._leaflet_id = null;
          mapEl.innerHTML = '';
        }
        __map = L.map('map').setView([35.68,139.76], 12);
        L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png',{ maxZoom:19, attribution:'&copy; OpenStreetMap' }).addTo(__map);
        let routePoints = extractLatLngsFromRoute(routeRow);
        console.log('[detail] routePoints=', routePoints.length);
        let lineSource = routeRow;
        if (routePoints.length < 2 && routeRow.route_type === 'from_run') {
          const fallbackRun = await resolveRunForRoute(routeRow);
          if (fallbackRun) {
            lineSource = fallbackRun;
            routePoints = extractLatLngsFromRoute(fallbackRun);
            console.log('[detail] routePoints (fallback run)=', routePoints.length);
          }
        }
        let routeLayer = drawLineOnMap(__map, lineSource.polyline, lineSource.geojson, COLORS.routePlanned);
        if ((!routeLayer || (routeLayer.getBounds && !routeLayer.getBounds().isValid())) && routePoints.length >= 2) {
          routeLayer = L.polyline(routePoints, { color: COLORS.routePlanned, weight:5 }).addTo(__map);
        }
        if (routePoints.length >= 1) fitMapToPoints(routePoints);
        await renderElevationPanel(routePoints);
        const photoPoints = await loadRoutePhotos(routeRow.id);
        if (routePoints.length < 2 && photoPoints.length >= 1) fitMapToPoints(photoPoints);

        // 自分のものだけトグル表示（ここで失敗してもメタ表示は残す）
        try{
          const acc = await getMyAccountId();
          if(acc && String(acc) === String(routeRow.account_id)){
            toggleWrap.style.display='block';
            toggle.checked = routeRow.is_public === true;
            toggle.onchange = async ()=>{
              try{
                const { error:e3 } = await client.from('routes').update({ is_public: !!toggle.checked }).eq('id', routeRow.id);
                if(e3){ console.error(e3); alert('更新失敗'); toggle.checked = !toggle.checked; }
              }catch(e){ console.error(e); alert('更新失敗'); toggle.checked = !toggle.checked; }
            };
          } else {
            toggleWrap.style.display='none';
          }
        }catch(toggleErr){
          console.warn('owner toggle skipped', toggleErr);
          toggleWrap.style.display='none';
        }
        window.__currentRouteId = routeRow.id;  // ← 保存時に使う
      }catch(e){
        box.textContent='読み込み失敗';
        console.error('loadRoute error', e);
        return;
      }
    }

    async function init(){
      await renderAuthBar();
      if(!id){
        alert('id が不正です');
        location.replace(`index.html?v=${V()}`);
        return;
      }
      if(kind==='run') { await loadRun(); }
      else { await loadRoute(); }
      client.auth.onAuthStateChange(async ()=>{ await renderAuthBar(); if(kind==='run') await loadRun(); else await loadRoute(); });
    }
    document.addEventListener('DOMContentLoaded', init, { once:true });
  </script>

<!-- ✅ ここから共通化パート -->
<script src="js/auth-common.js"></script>
<script>
  AuthCommon.init(client, { redirectUrl: 'index.html' });
  window.getMyAccountId = () => AuthCommon.getMyAccountId(client);
</script>

<script>
// --- モバイルvh補正（既に入れていなければ有効化） ---
function setVH(){ document.documentElement.style.setProperty('--vh', (window.innerHeight*0.01)+'px'); }
window.addEventListener('resize', setVH, {passive:true}); setVH();

// === 描画モード 管理 ===
const Draw = {
  active:false,
  pts:[],            // {lat, lng} の配列
  line:null,         // L.Polyline
  markers:[],        // L.CircleMarker[]
  _clickHandler:null
};
function updateDrawLayers(){
  try{
    if (!window.__map) return;
    // 線
    if (!Draw.line){
      Draw.line = L.polyline(Draw.pts, {weight:5}).addTo(__map);
    } else {
      Draw.line.setLatLngs(Draw.pts);
    }
    // マーカー
    Draw.markers.forEach(m=>m.remove());
    Draw.markers = Draw.pts.map(p=> L.circleMarker([p.lat, p.lng], {radius:5, weight:2, fillOpacity:1}).addTo(__map));
    // 表示範囲
    if (Draw.pts.length>=2){
      const b = L.latLngBounds(Draw.pts);
      __map.fitBounds(b, {padding:[20,20], maxZoom:16});
    } else if (Draw.pts.length===1){
      __map.setView(Draw.pts[0], 16);
    }
    // ステータス
    document.getElementById('drawStat').textContent = `点: ${Draw.pts.length} ・ 距離: ${fmtKm(sumDistance(Draw.pts))} km`;
  }catch(e){ console.warn(e); }
}
function fmtKm(m){ return (m/1000).toFixed(2); }
function haversine(a, b){
  const R=6371000, toRad=(x)=>x*Math.PI/180;
  const dLat=toRad(b.lat-a.lat), dLng=toRad(b.lng-a.lng);
  const s1=Math.sin(dLat/2), s2=Math.sin(dLng/2);
  const h=s1*s1 + Math.cos(toRad(a.lat))*Math.cos(toRad(b.lat))*s2*s2;
  return 2*R*Math.asin(Math.sqrt(h));
}
function sumDistance(pts){
  if (pts.length<2) return 0;
  let m=0; for(let i=1;i<pts.length;i++) m += haversine(pts[i-1], pts[i]);
  return m;
}

function enterDrawMode(){
  if (!window.__map){ alert('地図が初期化されていません'); return; }
  document.body.classList.add('mode-draw');
  document.getElementById('drawUI').style.display = 'flex';
  Draw.active = true;
  // 地図クリックで頂点追加
  Draw._clickHandler = (ev)=>{
    Draw.pts.push({ lat: ev.latlng.lat, lng: ev.latlng.lng });
    updateDrawLayers();
  };
  __map.on('click', Draw._clickHandler);
  setTimeout(()=> __map.invalidateSize(true), 220);
}
function exitDrawMode(){
  Draw.active = false;
  document.getElementById('drawUI').style.display = 'none';
  document.body.classList.remove('mode-draw');
  if (Draw._clickHandler && window.__map){ __map.off('click', Draw._clickHandler); }
  Draw._clickHandler = null;
  // レイヤは残してもよいが、通常画面を軽く保つため消去（好みで）
  if (Draw.line){ Draw.line.remove(); Draw.line=null; }
  Draw.markers.forEach(m=>m.remove());
  Draw.markers=[];
  setTimeout(()=> __map.invalidateSize(true), 220);
}

// 操作ボタン（DOM準備後に登録）
document.addEventListener('DOMContentLoaded', ()=>{
  const btnExit = document.getElementById('btnDrawExit');
  if (btnExit) btnExit.addEventListener('click', exitDrawMode);
  const btnUndo = document.getElementById('btnDrawUndo');
  if (btnUndo) btnUndo.addEventListener('click', ()=>{ if(Draw.pts.length){ Draw.pts.pop(); updateDrawLayers(); } });
  const btnClear = document.getElementById('btnDrawClear');
  if (btnClear) btnClear.addEventListener('click', ()=>{ Draw.pts=[]; updateDrawLayers(); });
});

// 保存：GeoJSON LineString と距離を routes に保存（polyline は null に）
async function saveDrawnRoute(){
  try{
    if (!window.__currentRouteId){ alert('ルートIDを特定できません'); return; }
    if (Draw.pts.length<2){ alert('少なくとも2点以上が必要です'); return; }
    // GeoJSON（[lng,lat]）
    const coords = Draw.pts.map(p=> [p.lng, p.lat]);
    const gj = { type:'LineString', coordinates: coords };
    const distance_m = Math.round(sumDistance(Draw.pts));
    const payload = { geojson: gj, polyline: null, distance_m };
    const { error } = await window.client.from('routes').update(payload).eq('id', window.__currentRouteId);
    if (error){ console.error(error); alert('保存に失敗しました'); return; }
    alert('保存しました');
    exitDrawMode();
    // 再描画（最新値の反映）
    if (typeof loadRoute === 'function') await loadRoute();
  }catch(e){ console.error(e); alert('保存に失敗しました'); }
}
document.addEventListener('DOMContentLoaded', ()=>{
  const btnSave = document.getElementById('btnDrawSave');
  if (btnSave) btnSave.addEventListener('click', saveDrawnRoute);
});

// ページに「描画モード」開始ボタンを生やす（既存ボタン群の近くに）
document.addEventListener('DOMContentLoaded', ()=>{
  const host = document.querySelector('main .card') || document.querySelector('main');
  const bar = document.createElement('div');
  bar.style.margin = '8px 0';
  // ルート詳細時のみ有効（run では非表示）
  const canDraw = (new URL(location.href).searchParams.get('kind') || 'run') === 'route';
  bar.innerHTML = canDraw ? `<button id="btnStartDraw" class="btn">描画モード</button>` : '';
  if (bar.innerHTML){
    const tgt = document.getElementById('btnToRoute')?.parentElement || host.firstElementChild;
    (tgt?.parentElement || host).insertBefore(bar, tgt);
    const btn = bar.querySelector('#btnStartDraw');
    if (btn) btn.addEventListener('click', enterDrawMode);
  }
});
</script>

</head>
<body>
  <header class="card" id="authBar"></header>

<main class="card">
    <div id="meta" style="margin-bottom:8px;">読み込み中…</div>
    <div id="toggleWrap" style="display:none; margin:8px 0;">
      <label><input type="checkbox" id="visToggle" /> 公開する</label>
    </div>
    <div style="margin:8px 0;">
      <button id="btnToRoute" class="btn" style="display:none;">このログをルート化する</button>
      <a class="btn" id="btnRunThis" href="#" style="margin-left:6px;">このルートで実走する</a>
      <script>
        (function(){
          const q = new URL(location.href).searchParams;
          const kindParam = q.get('kind');
          if (kindParam !== 'route') { document.getElementById('btnRunThis')?.remove(); return; }
          const rid = q.get('id');
          const a = document.getElementById('btnRunThis');
          if (a && rid) {
            a.href = `run.html?route=${encodeURIComponent(rid)}`;
            a.rel = 'noopener';
          }
        })();
      </script>
    </div>
    <div id="map"></div>
    <div id="elevBox" class="elev-card">
      <div style="font-weight:600;">標高・斜度</div>
      <div id="elevStats" class="muted" style="margin-top:4px;">標高データ取得中…</div>
      <svg id="elevChart"></svg>
    </div>
    <div id="photoBox" class="photo-box">
      <div class="photo-box-header">
        <div style="font-weight:600;">撮影写真</div>
        <a id="lnPhotoManage" class="photo-manage-link" href="#">管理</a>
      </div>
      <div id="photoStatus" class="muted" style="margin-top:4px;">写真読み込み中…</div>
      <div id="photoList" class="photo-list"></div>
    </div>

<!-- 描画モード用 パレット（必要時だけ表示） -->
<div id="drawUI" class="draw-toolbar" style="display:none;">
  <button id="btnDrawExit" class="btn">通常画面に戻る</button>
  <button id="btnDrawUndo" class="btn">取り消し</button>
  <button id="btnDrawClear" class="btn">全消去</button>
  <button id="btnDrawSave" class="btn" style="background:#eef2ff;">保存</button>
  <span class="muted" id="drawStat" style="align-self:center;">点: 0 ・ 距離: 0.00 km</span>
</div>

<!-- 実走記録中にだけ出る小さなオーバーレイUI -->
<div id="recUI" class="rec-overlay">
  <div class="stat">時間: <strong id="recTime">0:00</strong></div>
  <div class="stat">距離: <strong id="recDist">0.00 km</strong></div>
  <button id="btnStopRec" class="btn">停止して保存</button>
</div>

  </main>

<script>
  function drawLineOnMap(map, polyline, geojson, color){
    try{
      const col = color || COLORS.routePlanned;
      if(geojson){
        const gj = parseGeojsonMaybeTwice(geojson);
        if (!gj) return null;
        const layer = L.geoJSON(gj, { style:{ color: col, weight:5 }}).addTo(map);
        try{
          const bounds = layer.getBounds?.();
          if (bounds && bounds.isValid && bounds.isValid()) {
            map.fitBounds(bounds, { padding:[20,20], maxZoom:16 });
          }
        }catch(_){}
        return layer;
      }
      if(polyline){
        const latlngs = decodePolyline(polyline);
        if(latlngs.length){
          const line = L.polyline(latlngs,{ color: col, weight:5 }).addTo(map);
          map.fitBounds(line.getBounds(),{ padding:[20,20], maxZoom:16 });
          return line;
        }
      }
    }catch(e){ console.error('draw error', e); }
    return null;
  }
</script>

<script>
// ==== 実走記録（Run 作成） ====
// 依存: window.client（Supabase）, getMyAccountId(), __map（Leaflet）

// 状態
let _watchId = null, _timerId = null;
let _recStartMs = 0;
let _track = [];             // 全点（保存用）
let _meters = 0;
let _okLayer = null;         // 緑（オンルート）
let _offLayer = null;        // 赤（逸脱）
let _lastP = null;
let _planned = [];           // 予定ルートの座標配列（kind=route 時のみセット）
const OFF_THRESHOLD_M = 30;  // 逸脱判定の閾値（お好みで 20〜50m）

function fmtMinSec(sec){ const m = Math.floor(sec/60), s = sec%60|0; return `${m}:${String(s).padStart(2,'0')}`; }
function fmtKm(m){ return (m/1000).toFixed(2); }
function haversine(a,b){
  const R=6371000, toRad=x=>x*Math.PI/180;
  const dLat=toRad(b.lat-a.lat), dLng=toRad(b.lng-a.lng);
  const s1=Math.sin(dLat/2), s2=Math.sin(dLng/2);
  const h=s1*s1 + Math.cos(toRad(a.lat))*Math.cos(toRad(b.lat))*s2*s2;
  return 2*R*Math.asin(Math.sqrt(h));
}

function showRecUI(show){ document.getElementById('recUI').style.display = show ? 'flex' : 'none'; }

// 実走開始
async function startRunRecording(){
  const acc = await getMyAccountId();
  if (!acc) { alert('ログインが必要です'); return; }
  if (!navigator.geolocation) { alert('この端末は位置情報に対応していません'); return; }

  _track = []; _meters = 0; _lastP = null; _recStartMs = Date.now();
  document.getElementById('recTime').textContent = '0:00';
  document.getElementById('recDist').textContent = '0.00 km';
  showRecUI(true);

  if (!__map){
    alert('地図の初期化が完了していません。少し待ってから再度お試しください。');
    showRecUI(false);
    return;
  }

  _planned = [];
  // 予定ルート（kind=routeの時だけ取得）
  try{
    const q = new URL(location.href).searchParams;
    const kind = (q.get('kind')||'run');
    if (kind === 'route') {
      if (__currentRoute){
        _planned = extractLatLngsFromRoute(__currentRoute) || [];
      } else {
        const id = Number(q.get('id'));
        const { data: route } = await client.from('routes').select('*').eq('id', id).maybeSingle();
        _planned = route ? extractLatLngsFromRoute(route) : [];
      }
    } else {
      _planned = [];
    }
  }catch(e){ console.warn('planned fetch', e); }

  // 地図レイヤ初期化（緑／赤）
  try{
    if (_okLayer){ _okLayer.remove(); _okLayer = null; }
    if (_offLayer){ _offLayer.remove(); _offLayer = null; }
    _okLayer  = L.polyline([], { color: COLORS.liveOnRoute,  weight:5 }).addTo(__map);
    _offLayer = L.polyline([], { color: COLORS.liveOffRoute, weight:5 }).addTo(__map);
  }catch(e){ console.warn(e); }

  _timerId = setInterval(()=>{
    const sec = ((Date.now()-_recStartMs)/1000)|0;
    document.getElementById('recTime').textContent = fmtMinSec(sec);
    document.getElementById('recDist').textContent = `${fmtKm(_meters)} km`;
  }, 1000);

  _watchId = navigator.geolocation.watchPosition(onPos, onPosError, {
    enableHighAccuracy:true, maximumAge:1000, timeout:10000
  });

  const btn = document.getElementById('btnStartRec'); if (btn) btn.disabled = true;
}

function onPosError(err){ console.warn('geo error', err); }

// 位置更新
function onPos(pos){
  const p = { lat: pos.coords.latitude, lng: pos.coords.longitude, ts: Date.now(), acc: pos.coords.accuracy||0 };

  if (p.acc && p.acc > 50) return;

  if (!_lastP){
    _track.push(p);
    _lastP = p;
    if (__map) __map.setView([p.lat, p.lng], 16);
    pushToLiveLayer(p);
    return;
  }

  const d = haversine(_lastP, p);
  if (d < 10) return;

  _meters += d;
  _track.push(p);
  _lastP = p;

  pushToLiveLayer(p);

  try{
    if (__map) __map.panTo([p.lat, p.lng], { animate:false });
  }catch(e){ console.warn(e); }
}

// 予定ルートへの距離で緑/赤に振り分け
function pushToLiveLayer(p){
  try{
    if (_planned && _planned.length >= 2){
      const dist = distancePointToPolylineMeters(p, _planned);
      if (dist <= OFF_THRESHOLD_M){
        _okLayer?.addLatLng?.([p.lat, p.lng]);
      } else {
        _offLayer?.addLatLng?.([p.lat, p.lng]);
      }
    } else {
      _okLayer?.addLatLng?.([p.lat, p.lng]);
    }
  }catch(e){ console.warn(e); }
}

// 停止＆保存
async function stopRunRecordingAndSave(){
  try{
    if (_watchId!=null){ navigator.geolocation.clearWatch(_watchId); _watchId = null; }
    if (_timerId!=null){ clearInterval(_timerId); _timerId = null; }
    showRecUI(false);

    // 記録が短すぎる場合
    if (_track.length < 2) { alert('記録が短すぎます（2点以上必要）'); return; }

    const acc = await getMyAccountId();
    if (!acc) { alert('ログインが必要です'); return; }

    // 走行時間
    const endedMs = Date.now();
    const duration_s = Math.max(1, ((endedMs - _recStartMs)/1000)|0);
    const distance_m = Math.round(_meters);

    // GeoJSON LineString（[lng,lat]）
    const coords = _track.map(p => [p.lng, p.lat]);
    const gj = { type:'LineString', coordinates: coords };

    // レコード作成
    const payload = {
      account_id: acc,
      started_at: new Date(_recStartMs).toISOString(),
      ended_at:   new Date(endedMs).toISOString(),
      distance_m,
      duration_s,
      geojson: gj,     // polyline は未使用。必要なら後で encode を足せます
      polyline: null
    };

    const { data:newRow, error } = await client.from('runs')
      .insert([payload]).select('id').maybeSingle();

    if (error || !newRow){ console.error(error); alert('保存に失敗しました'); return; }

    // Run 詳細へ遷移（既存UIに合わせて kind=run）
    location.href = `detail.html?id=${encodeURIComponent(newRow.id)}&kind=run&v=${V()}`;

  }catch(e){
    console.error(e);
    alert('保存に失敗しました');
  }finally{
    try{
      _okLayer?.remove(); _okLayer = null;
      _offLayer?.remove(); _offLayer = null;
    }catch(_){}
    const btn = document.getElementById('btnStartRec'); if (btn) btn.disabled = false;
  }
}
</script>

  <footer class="muted" style="margin-top:14px;">v: <script>document.write(window.APP_VERSION)</script></footer>
<script>
  if ('serviceWorker' in navigator) {
    // いったん既存SWを解除してから、バージョン付きURLで登録
    (async () => {
      try {
        const v = window.APP_VERSION || '';
        // 念のため登録前に不要SWを掃除（1度だけでOK）
        const regs = await navigator.serviceWorker.getRegistrations();
        await Promise.all(regs.map(r => r.unregister()));

        const swUrl = `./service-worker.js?v=${encodeURIComponent(v)}`;
        const reg = await navigator.serviceWorker.register(swUrl, { scope: './' });

        // すぐに新SWへ切替
        if (reg.waiting) { reg.waiting.postMessage({ type: 'SKIP_WAITING' }); }
        reg.addEventListener('updatefound', () => {
          const nw = reg.installing;
          if (!nw) return;
          nw.addEventListener('statechange', () => {
            if (nw.state === 'installed' && navigator.serviceWorker.controller) {
              // 新SWが入ったので即時乗り換えを依頼
              reg.waiting?.postMessage({ type: 'SKIP_WAITING' });
            }
          });
        });

        // 明示的にアップデートを促す
        await reg.update();
      } catch (e) {
        console.error('SW register failed', e);
      }
    })();
  }
</script>
</body>
</html>
