<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Detail</title>
  <link rel="icon" href="data:,">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="" />
  <style>
    body { font-family: system-ui,-apple-system,Segoe UI,Roboto; max-width: 920px; margin: 20px auto; padding: 0 12px; color:#111827; }
    .btn { padding:6px 10px; border:1px solid #e5e7eb; border-radius:8px; background:#fff; cursor:pointer; }
    .card { border:1px solid #e5e7eb; border-radius:10px; padding:10px 12px; margin:10px 0; background:#fff; }
    #map { height: 60vh; border:1px solid #e5e7eb; border-radius:10px; }
    .muted{ color:#6b7280; }

/* --- 描画モード：地図を実質フルスクリーン化 --- */
body.mode-draw #map { height: calc(var(--vh, 1vh) * 100); }

/* 描画ツールバー（パレット） */
.draw-toolbar{
  position: fixed;
  left: 50%;
  transform: translateX(-50%);
  top: 10px;
  display: flex; gap: 8px; flex-wrap: wrap;
  background: rgba(255,255,255,.96);
  border: 1px solid #e5e7eb; border-radius: 12px;
  padding: 8px 10px;
  box-shadow: 0 2px 12px rgba(0,0,0,.1);
  z-index: 5000;
}
.draw-toolbar .btn { padding:8px 12px; border-radius:10px; }

/* スマホ最適化 */
@media (max-width: 600px) {
  .draw-toolbar{ top: 8px; padding: 10px 12px; }
  .draw-toolbar .btn{ padding: 10px 14px; }
}

/* 既存：閲覧/記録モードの高さ基準（そのまま利用） */
#map { height: 50vh; transition: height .2s ease; }
@media (max-width: 600px) { #map{ height: 45vh; } }
body.mode-record #map { height: calc(var(--vh, 1vh) * 90); }

.rec-overlay {
  position: fixed;
  left: 50%;
  transform: translateX(-50%);
  bottom: 12px;
  display: none; gap: 8px;
  background: rgba(255,255,255,.92);
  border: 1px solid #e5e7eb; border-radius: 12px;
  padding: 8px 10px;
  box-shadow: 0 2px 12px rgba(0,0,0,.08);
  z-index: 5000;
}
.rec-overlay .stat { font-size: 12px; color: #374151; }
.rec-overlay .stat strong { font-size: 14px; }
@media (max-width: 600px) {
  .rec-overlay { bottom: 10px; padding: 10px 12px; }
  .rec-overlay .btn { padding: 10px 14px; border-radius: 12px; }
}

</style>

<script src="js/version.js"></script>

<script>
  const COLORS = {
    routePlanned: '#3b82f6', // 青
    runRecorded:  '#ef4444', // 既存（履歴Runの表示に使用：赤）
    liveOnRoute:  '#10b981', // 実走オンルート：緑
    liveOffRoute: '#ef4444'  // 実走逸脱：赤
  };
</script>

<script>
  // 1) バージョン管理：変わったらSWもCacheも全消し → 強制再読込
  async function hardRefreshIfVersionChanged() {
    try {
      const v = String(window.APP_VERSION || '');
      const prev = localStorage.getItem('APP_VERSION');
      if (prev && prev !== v) {
        // 既存SWを全部解除
        if ('serviceWorker' in navigator) {
          const regs = await navigator.serviceWorker.getRegistrations();
          await Promise.all(regs.map(r => r.unregister()));
        }
        // 既存Cacheを全削除
        if (window.caches?.keys) {
          const keys = await caches.keys();
          await Promise.all(keys.map(k => caches.delete(k)));
        }
        localStorage.setItem('APP_VERSION', v);
        // ハードリロード
        location.replace(location.pathname + '?v=' + encodeURIComponent(v) + '&t=' + Date.now());
        return;
      }
      localStorage.setItem('APP_VERSION', v);
    } catch (e) { console.warn('hardRefreshIfVersionChanged', e); }
  }

  // 2) すぐ実行（SW登録より先に）
  hardRefreshIfVersionChanged();
</script>
<script>
    if (typeof window.APP_VERSION === 'undefined' || !window.APP_VERSION) {
      window.APP_VERSION = new Date().toISOString().slice(0,10) + '-dev';
    }
  </script>

  <script src="https://unpkg.com/@supabase/supabase-js@2/dist/umd/supabase.js"></script>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
  <script>
    const SUPABASE_URL = "https://cqiqhczxuiyakptdjowr.supabase.co";
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNxaXFoY3p4dWl5YWtwdGRqb3dyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTc3NzAwNzMsImV4cCI6MjA3MzM0NjA3M30.vCFQoQnsClINKa5tQAz-rNnF5XLEukmn_Nl0Err5k3k";
    const client = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY, { auth:{ persistSession:true, autoRefreshToken:true, detectSessionInUrl:false } });
    window.client = client; // デバッグ用に公開

    const V = ()=> encodeURIComponent(window.APP_VERSION||'');
    const $ = (s)=> document.querySelector(s);
    const q = new URL(location.href).searchParams;
    const id = Number(q.get('id'));
    const kind = q.get('kind') || 'run';
    let __map;
    let __currentRoute = null;

    async function getSession(){ const { data:{ session } } = await client.auth.getSession(); return session; }
    async function getMyAccountId(){ try{ const s=await getSession(); if(!s?.user) return null; const { data, error } = await client.from('users').select('account_id').eq('id', s.user.id).maybeSingle(); if(error){ console.error(error); return null; } return data?.account_id ?? null; }catch(e){ console.error(e); return null; } }

    function decodePolyline(str){ try{ let idx=0, lat=0, lng=0, arr=[]; while(idx<str.length){ let b,shift=0,result=0; do{ b=str.charCodeAt(idx++)-63; result|=(b&0x1f)<<shift; shift+=5; }while(b>=0x20); let dlat=(result&1)?~(result>>1):(result>>1); shift=0; result=0; do{ b=str.charCodeAt(idx++)-63; result|=(b&0x1f)<<shift; shift+=5; }while(b>=0x20); let dlng=(result&1)?~(result>>1):(result>>1); lat+=dlat; lng+=dlng; arr.push([lat/1e5,lng/1e5]); } return arr; }catch(e){ console.error('decodePolyline', e); return []; } }
    function extractLatLngsFromRoute(route){
      try{
        if (route?.geojson){
          const g = typeof route.geojson==='string' ? JSON.parse(route.geojson) : route.geojson;
          const out = [];
          const walk = (geom)=>{
            if(!geom) return;
            const t = geom.type;
            const co = geom.coordinates;
            if (t==='LineString'){
              co.forEach(([lng,lat])=> out.push({lat,lng}));
            } else if (t==='MultiLineString'){
              co.forEach(line=> line.forEach(([lng,lat])=> out.push({lat,lng})));
            } else if (t==='GeometryCollection'){
              (geom.geometries||[]).forEach(walk);
            }
          };
          if (g.type==='Feature') walk(g.geometry);
          else if (g.type==='FeatureCollection') (g.features||[]).forEach(f=> walk(f.geometry));
          else walk(g);
          if (out.length) return out;
        }
      }catch(e){ console.warn('extract geojson', e); }
      if (route?.polyline){
        return decodePolyline(route.polyline).map(([lat,lng])=>({lat,lng}));
      }
      return [];
    }
    function distancePointToSegmentMeters(p, a, b){
      const latFactor = 111320;
      const lonFactor = 111320 * Math.cos(((a.lat + b.lat) / 2) * Math.PI / 180);
      const ax = a.lng * lonFactor, ay = a.lat * latFactor;
      const bx = b.lng * lonFactor, by = b.lat * latFactor;
      const px = p.lng * lonFactor, py = p.lat * latFactor;
      const vx = bx - ax, vy = by - ay;
      const wx = px - ax, wy = py - ay;
      const c1 = vx * wx + vy * wy;
      const c2 = vx * vx + vy * vy;
      let t = c2 > 0 ? (c1 / c2) : 0;
      t = Math.max(0, Math.min(1, t));
      const sx = ax + t * vx, sy = ay + t * vy;
      const dx = px - sx, dy = py - sy;
      return Math.sqrt(dx * dx + dy * dy);
    }
    function distancePointToPolylineMeters(p, line){
      if (!line || line.length < 2) return Infinity;
      let best = Infinity;
      for (let i = 1; i < line.length; i++){
        const d = distancePointToSegmentMeters(p, line[i-1], line[i]);
        if (d < best) best = d;
      }
      return best;
    }

    async function renderAuthBar(){
      const bar = $('#authBar');
      try{
        const s = await getSession();
        if(!s?.user){
          bar.innerHTML = `未ログインです。<a class="btn" href="login.html?v=${V()}">ログインへ</a>`;
          return;
        }
        const email = s.user.email || '';
        bar.innerHTML = `
          ログイン中: <strong>${email}</strong>
          <button class="btn" data-signout style="margin-left:8px">Sign out</button>
          <a class="btn" style="margin-left:6px" href="mypage.html?v=${V()}">マイページへ</a>
          <a class="btn" style="margin-left:6px" href="index.html?v=${V()}">トップへ</a>
        `;
      }catch(e){ bar.textContent='認証状態の取得に失敗しました'; console.error(e); }
    }

    async function loadRun(){
      const box = $('#meta'); const btn = $('#btnToRoute');
      try{
        const { data: run, error } = await client.from('runs').select('id,started_at,ended_at,distance_m,duration_s,polyline,geojson,account_id').eq('id', id).maybeSingle();
        if(error || !run){ box.textContent='読み込み失敗'; console.error(error); return; }
        const when = run.ended_at ? new Date(run.ended_at).toLocaleString() : (run.started_at? new Date(run.started_at).toLocaleString():'-');
        const km = run.distance_m!=null ? (Number(run.distance_m)/1000).toFixed(2)+' km' : '-';
        const min = run.duration_s!=null ? Math.round(Number(run.duration_s)/60)+' 分' : '-';
        box.innerHTML = `<div>日時: ${when}</div><div class=\"muted\">距離: ${km} ・ 時間: ${min}</div>`;
        const mapEl = document.getElementById('map');
        if (__map) {
          __map.remove();
          __map = undefined;
        }
        if (mapEl && mapEl._leaflet_id) {
          mapEl._leaflet_id = null;
          mapEl.innerHTML = '';
        }
        __map = L.map('map').setView([35.68,139.76], 12);
        L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png',{ maxZoom:19, attribution:'&copy; OpenStreetMap' }).addTo(__map);
        drawLineOnMap(__map, run.polyline, run.geojson, COLORS.runRecorded);

        // ルート化ボタン
        btn.style.display='inline-block';
        btn.onclick = async ()=>{
          try{
            const acc = await getMyAccountId(); if(!acc){ alert('ログインが必要です'); return; }
            const ymd = (d=> `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`)(new Date(run.ended_at||run.started_at||Date.now()));
            const payload = { name: `Run ${ymd} のルート`, account_id: acc, is_public: false, route_type: 'from_run', source_run_id: run.id, polyline: run.polyline ?? null, geojson: run.geojson ?? null };
            const { data:newRow, error:e2 } = await client.from('routes').insert([payload]).select('id').maybeSingle();
            if(e2 || !newRow){ console.error(e2); alert('作成に失敗'); return; }
            location.href = `detail.html?id=${encodeURIComponent(newRow.id)}&kind=route&v=${V()}`;
          }catch(e){ console.error(e); alert('作成に失敗'); }
        };
      }catch(e){ box.textContent='読み込み失敗'; console.error(e); }
    }

    async function loadRoute(){
      const box = $('#meta'); const toggleWrap = $('#toggleWrap'); const toggle = $('#visToggle');
      try{
        const { data: route, error } = await client.from('routes')
          .select('*')
          .eq('id', id).maybeSingle();
        if(error || !route){ box.textContent='読み込み失敗'; console.error(error); return; }
        __currentRoute = route;
        const when = route.created_at ? new Date(route.created_at).toLocaleString() : '-';
        const km = route.distance_m != null ? (Number(route.distance_m)/1000).toFixed(2)+' km' : '-';
        const min = route.duration_s != null ? Math.round(Number(route.duration_s)/60)+' 分' : '-';
        const typeBadge = route.route_type === 'from_run' ? 'ログ由来' : (route.route_type || '');
        const pubBadge = route.is_public ? '公開' : '非公開';
        const owner = route.account_id || '-';
        const descBlock = route.description ? `<div class="muted" style="margin-top:4px;">説明: ${route.description}</div>` : '';
        const typeBlock = `
          <div style="margin-top:6px;">
            ${typeBadge ? `<span class=\"muted\" style=\"margin-right:8px;\">[${typeBadge}]</span>` : ''}
            <span class="muted">[${pubBadge}]</span>
          </div>`;
        const ownerBlock = `<div class="muted" style="margin-top:4px;">Owner Account: ${owner}</div>`;
        const sourceBlock = route.source_run_id ? `
          <div style="margin-top:6px;">
            元ログ: <a class="btn" href="detail.html?id=${encodeURIComponent(route.source_run_id)}&kind=run&v=${V()}">Run #${route.source_run_id}</a>
          </div>
        ` : '';
        box.innerHTML = `
          <div style="font-size:18px;font-weight:600;">Route #${route.id}</div>
          <div>名称: <strong>${route.name || '(無題ルート)'}</strong></div>
          <div class="muted">作成日: ${when}</div>
          <div class="muted">距離: ${km} ・ 時間: ${min}</div>
          ${descBlock}
          ${typeBlock}
          ${ownerBlock}
          ${sourceBlock}
        `;
        const mapEl = document.getElementById('map');
        if (__map) {
          __map.remove();
          __map = undefined;
        }
        if (mapEl && mapEl._leaflet_id) {
          mapEl._leaflet_id = null;
          mapEl.innerHTML = '';
        }
        __map = L.map('map').setView([35.68,139.76], 12);
        L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png',{ maxZoom:19, attribution:'&copy; OpenStreetMap' }).addTo(__map);
        drawLineOnMap(__map, route.polyline, route.geojson, COLORS.routePlanned);

        // 自分のものだけトグル表示（ここで失敗してもメタ表示は残す）
        try{
          const acc = await getMyAccountId();
          if(acc && String(acc) === String(route.account_id)){
            toggleWrap.style.display='block';
            toggle.checked = route.is_public === true;
            toggle.onchange = async ()=>{
              try{
                const { error:e3 } = await client.from('routes').update({ is_public: !!toggle.checked }).eq('id', route.id);
                if(e3){ console.error(e3); alert('更新失敗'); toggle.checked = !toggle.checked; }
              }catch(e){ console.error(e); alert('更新失敗'); toggle.checked = !toggle.checked; }
            };
          } else {
            toggleWrap.style.display='none';
          }
        }catch(toggleErr){
          console.warn('owner toggle skipped', toggleErr);
          toggleWrap.style.display='none';
        }
      }catch(e){
        box.textContent='読み込み失敗';
        console.error('loadRoute error', e);
      }

      window.__currentRouteId = route.id;  // ← 保存時に使う
    }

    async function init(){
      await renderAuthBar();
      if(!id){ alert('id が不正です'); return; }
      if(kind==='run') { await loadRun(); }
      else { await loadRoute(); }
      client.auth.onAuthStateChange(async ()=>{ await renderAuthBar(); if(kind==='run') await loadRun(); else await loadRoute(); });
    }
    document.addEventListener('DOMContentLoaded', init, { once:true });
  </script>

<!-- ✅ ここから共通化パート -->
<script src="js/auth-common.js"></script>
<script>
  AuthCommon.init(client, { redirectUrl: 'index.html' });
</script>

<script>
// --- モバイルvh補正（既に入れていなければ有効化） ---
function setVH(){ document.documentElement.style.setProperty('--vh', (window.innerHeight*0.01)+'px'); }
window.addEventListener('resize', setVH, {passive:true}); setVH();

// === 描画モード 管理 ===
const Draw = {
  active:false,
  pts:[],            // {lat, lng} の配列
  line:null,         // L.Polyline
  markers:[],        // L.CircleMarker[]
  _clickHandler:null
};
function updateDrawLayers(){
  try{
    if (!window.__map) return;
    // 線
    if (!Draw.line){
      Draw.line = L.polyline(Draw.pts, {weight:5}).addTo(__map);
    } else {
      Draw.line.setLatLngs(Draw.pts);
    }
    // マーカー
    Draw.markers.forEach(m=>m.remove());
    Draw.markers = Draw.pts.map(p=> L.circleMarker([p.lat, p.lng], {radius:5, weight:2, fillOpacity:1}).addTo(__map));
    // 表示範囲
    if (Draw.pts.length>=2){
      const b = L.latLngBounds(Draw.pts);
      __map.fitBounds(b, {padding:[20,20], maxZoom:16});
    } else if (Draw.pts.length===1){
      __map.setView(Draw.pts[0], 16);
    }
    // ステータス
    document.getElementById('drawStat').textContent = `点: ${Draw.pts.length} ・ 距離: ${fmtKm(sumDistance(Draw.pts))} km`;
  }catch(e){ console.warn(e); }
}
function fmtKm(m){ return (m/1000).toFixed(2); }
function haversine(a, b){
  const R=6371000, toRad=(x)=>x*Math.PI/180;
  const dLat=toRad(b.lat-a.lat), dLng=toRad(b.lng-a.lng);
  const s1=Math.sin(dLat/2), s2=Math.sin(dLng/2);
  const h=s1*s1 + Math.cos(toRad(a.lat))*Math.cos(toRad(b.lat))*s2*s2;
  return 2*R*Math.asin(Math.sqrt(h));
}
function sumDistance(pts){
  if (pts.length<2) return 0;
  let m=0; for(let i=1;i<pts.length;i++) m += haversine(pts[i-1], pts[i]);
  return m;
}

function enterDrawMode(){
  if (!window.__map){ alert('地図が初期化されていません'); return; }
  document.body.classList.add('mode-draw');
  document.getElementById('drawUI').style.display = 'flex';
  Draw.active = true;
  // 地図クリックで頂点追加
  Draw._clickHandler = (ev)=>{
    Draw.pts.push({ lat: ev.latlng.lat, lng: ev.latlng.lng });
    updateDrawLayers();
  };
  __map.on('click', Draw._clickHandler);
  setTimeout(()=> __map.invalidateSize(true), 220);
}
function exitDrawMode(){
  Draw.active = false;
  document.getElementById('drawUI').style.display = 'none';
  document.body.classList.remove('mode-draw');
  if (Draw._clickHandler && window.__map){ __map.off('click', Draw._clickHandler); }
  Draw._clickHandler = null;
  // レイヤは残してもよいが、通常画面を軽く保つため消去（好みで）
  if (Draw.line){ Draw.line.remove(); Draw.line=null; }
  Draw.markers.forEach(m=>m.remove());
  Draw.markers=[];
  setTimeout(()=> __map.invalidateSize(true), 220);
}

// 操作ボタン
document.getElementById('btnDrawExit').onclick = exitDrawMode;
document.getElementById('btnDrawUndo').onclick = ()=>{ if(Draw.pts.length){ Draw.pts.pop(); updateDrawLayers(); } };
document.getElementById('btnDrawClear').onclick = ()=>{ Draw.pts=[]; updateDrawLayers(); };

// 保存：GeoJSON LineString と距離を routes に保存（polyline は null に）
async function saveDrawnRoute(){
  try{
    if (!window.__currentRouteId){ alert('ルートIDを特定できません'); return; }
    if (Draw.pts.length<2){ alert('少なくとも2点以上が必要です'); return; }
    // GeoJSON（[lng,lat]）
    const coords = Draw.pts.map(p=> [p.lng, p.lat]);
    const gj = { type:'LineString', coordinates: coords };
    const distance_m = Math.round(sumDistance(Draw.pts));
    const payload = { geojson: gj, polyline: null, distance_m };
    const { error } = await window.client.from('routes').update(payload).eq('id', window.__currentRouteId);
    if (error){ console.error(error); alert('保存に失敗しました'); return; }
    alert('保存しました');
    exitDrawMode();
    // 再描画（最新値の反映）
    if (typeof loadRoute === 'function') await loadRoute();
  }catch(e){ console.error(e); alert('保存に失敗しました'); }
}
document.getElementById('btnDrawSave').onclick = saveDrawnRoute;

// ページに「描画モード」開始ボタンを生やす（既存ボタン群の近くに）
document.addEventListener('DOMContentLoaded', ()=>{
  const host = document.querySelector('main .card') || document.querySelector('main');
  const bar = document.createElement('div');
  bar.style.margin = '8px 0';
  // ルート詳細時のみ有効（run では非表示）
  const canDraw = (new URL(location.href).searchParams.get('kind') || 'run') === 'route';
  bar.innerHTML = canDraw ? `<button id="btnStartDraw" class="btn">描画モード</button>` : '';
  if (bar.innerHTML){
    const tgt = document.getElementById('btnToRoute')?.parentElement || host.firstElementChild;
    (tgt?.parentElement || host).insertBefore(bar, tgt);
    document.getElementById('btnStartDraw').onclick = enterDrawMode;
  }
});
</script>

</head>
<body>
  <header class="card" id="authBar"></header>

  <main class="card">
    <div id="meta" style="margin-bottom:8px;">読み込み中…</div>
    <div id="toggleWrap" style="display:none; margin:8px 0;">
      <label><input type="checkbox" id="visToggle" /> 公開する</label>
    </div>
    <div style="margin:8px 0;">
      <button id="btnToRoute" class="btn" style="display:none;">このログをルート化する</button>
    </div>
    <div id="map"></div>

<!-- 描画モード用 パレット（必要時だけ表示） -->
<div id="drawUI" class="draw-toolbar" style="display:none;">
  <button id="btnDrawExit" class="btn">通常画面に戻る</button>
  <button id="btnDrawUndo" class="btn">取り消し</button>
  <button id="btnDrawClear" class="btn">全消去</button>
  <button id="btnDrawSave" class="btn" style="background:#eef2ff;">保存</button>
  <span class="muted" id="drawStat" style="align-self:center;">点: 0 ・ 距離: 0.00 km</span>
</div>

<!-- 実走記録中にだけ出る小さなオーバーレイUI -->
<div id="recUI" class="rec-overlay">
  <div class="stat">時間: <strong id="recTime">0:00</strong></div>
  <div class="stat">距離: <strong id="recDist">0.00 km</strong></div>
  <button id="btnStopRec" class="btn">停止して保存</button>
</div>

  </main>

<script>
  function drawLineOnMap(map, polyline, geojson, color){
    try{
      const col = color || COLORS.routePlanned;
      if(geojson){
        let gj = typeof geojson==='string'? JSON.parse(geojson): geojson;
        L.geoJSON(gj, { style:{ color: col, weight:5 }}).addTo(map);
        try{ const layer = L.geoJSON(gj); map.fitBounds(layer.getBounds(), { padding:[20,20], maxZoom:16 }); }catch(_){}
        return;
      }
      if(polyline){
        const latlngs = decodePolyline(polyline);
        if(latlngs.length){
          const line = L.polyline(latlngs,{ color: col, weight:5 }).addTo(map);
          map.fitBounds(line.getBounds(),{ padding:[20,20], maxZoom:16 });
        }
      }
    }catch(e){ console.error('draw error', e); }
  }
</script>

<script>
// ==== 実走記録（Run 作成） ====
// 依存: window.client（Supabase）, getMyAccountId(), __map（Leaflet）

// 画面に「実走を記録」ボタンを生やす（既存ボタンの近くに）
document.addEventListener('DOMContentLoaded', () => {
  const host = document.querySelector('main .card') || document.querySelector('main');
  const bar  = document.createElement('div');
  bar.style.margin = '8px 0';
  bar.innerHTML = `<button id="btnStartRec" class="btn">実走を記録</button>`;
  const tgt = document.getElementById('btnToRoute')?.parentElement || host.firstElementChild;
  (tgt?.parentElement || host).insertBefore(bar, tgt);

  document.getElementById('btnStartRec').onclick = startRunRecording;
  document.getElementById('btnStopRec').onclick  = stopRunRecordingAndSave;
});

// 状態
let _watchId = null, _timerId = null;
let _recStartMs = 0;
let _track = [];             // 全点（保存用）
let _meters = 0;
let _okLayer = null;         // 緑（オンルート）
let _offLayer = null;        // 赤（逸脱）
let _lastP = null;
let _planned = [];           // 予定ルートの座標配列（kind=route 時のみセット）
const OFF_THRESHOLD_M = 30;  // 逸脱判定の閾値（お好みで 20〜50m）

function fmtMinSec(sec){ const m = Math.floor(sec/60), s = sec%60|0; return `${m}:${String(s).padStart(2,'0')}`; }
function fmtKm(m){ return (m/1000).toFixed(2); }
function haversine(a,b){
  const R=6371000, toRad=x=>x*Math.PI/180;
  const dLat=toRad(b.lat-a.lat), dLng=toRad(b.lng-a.lng);
  const s1=Math.sin(dLat/2), s2=Math.sin(dLng/2);
  const h=s1*s1 + Math.cos(toRad(a.lat))*Math.cos(toRad(b.lat))*s2*s2;
  return 2*R*Math.asin(Math.sqrt(h));
}

function showRecUI(show){ document.getElementById('recUI').style.display = show ? 'flex' : 'none'; }

// 実走開始
async function startRunRecording(){
  const acc = await getMyAccountId();
  if (!acc) { alert('ログインが必要です'); return; }
  if (!navigator.geolocation) { alert('この端末は位置情報に対応していません'); return; }

  _track = []; _meters = 0; _lastP = null; _recStartMs = Date.now();
  document.getElementById('recTime').textContent = '0:00';
  document.getElementById('recDist').textContent = '0.00 km';
  showRecUI(true);

  if (!__map){
    alert('地図の初期化が完了していません。少し待ってから再度お試しください。');
    showRecUI(false);
    return;
  }

  _planned = [];
  // 予定ルート（kind=routeの時だけ取得）
  try{
    const q = new URL(location.href).searchParams;
    const kind = (q.get('kind')||'run');
    if (kind === 'route') {
      if (__currentRoute){
        _planned = extractLatLngsFromRoute(__currentRoute) || [];
      } else {
        const id = Number(q.get('id'));
        const { data: route } = await client.from('routes').select('*').eq('id', id).maybeSingle();
        _planned = route ? extractLatLngsFromRoute(route) : [];
      }
    } else {
      _planned = [];
    }
  }catch(e){ console.warn('planned fetch', e); }

  // 地図レイヤ初期化（緑／赤）
  try{
    if (_okLayer){ _okLayer.remove(); _okLayer = null; }
    if (_offLayer){ _offLayer.remove(); _offLayer = null; }
    _okLayer  = L.polyline([], { color: COLORS.liveOnRoute,  weight:5 }).addTo(__map);
    _offLayer = L.polyline([], { color: COLORS.liveOffRoute, weight:5 }).addTo(__map);
  }catch(e){ console.warn(e); }

  _timerId = setInterval(()=>{
    const sec = ((Date.now()-_recStartMs)/1000)|0;
    document.getElementById('recTime').textContent = fmtMinSec(sec);
    document.getElementById('recDist').textContent = `${fmtKm(_meters)} km`;
  }, 1000);

  _watchId = navigator.geolocation.watchPosition(onPos, onPosError, {
    enableHighAccuracy:true, maximumAge:1000, timeout:10000
  });

  const btn = document.getElementById('btnStartRec'); if (btn) btn.disabled = true;
}

function onPosError(err){ console.warn('geo error', err); }

// 位置更新
function onPos(pos){
  const p = { lat: pos.coords.latitude, lng: pos.coords.longitude, ts: Date.now(), acc: pos.coords.accuracy||0 };

  if (p.acc && p.acc > 50) return;

  if (!_lastP){
    _track.push(p);
    _lastP = p;
    if (__map) __map.setView([p.lat, p.lng], 16);
    pushToLiveLayer(p);
    return;
  }

  const d = haversine(_lastP, p);
  if (d < 10) return;

  _meters += d;
  _track.push(p);
  _lastP = p;

  pushToLiveLayer(p);

  try{
    if (__map) __map.panTo([p.lat, p.lng], { animate:false });
  }catch(e){ console.warn(e); }
}

// 予定ルートへの距離で緑/赤に振り分け
function pushToLiveLayer(p){
  try{
    if (_planned && _planned.length >= 2){
      const dist = distancePointToPolylineMeters(p, _planned);
      if (dist <= OFF_THRESHOLD_M){
        _okLayer?.addLatLng?.([p.lat, p.lng]);
      } else {
        _offLayer?.addLatLng?.([p.lat, p.lng]);
      }
    } else {
      _okLayer?.addLatLng?.([p.lat, p.lng]);
    }
  }catch(e){ console.warn(e); }
}

// 停止＆保存
async function stopRunRecordingAndSave(){
  try{
    if (_watchId!=null){ navigator.geolocation.clearWatch(_watchId); _watchId = null; }
    if (_timerId!=null){ clearInterval(_timerId); _timerId = null; }
    showRecUI(false);

    // 記録が短すぎる場合
    if (_track.length < 2) { alert('記録が短すぎます（2点以上必要）'); return; }

    const acc = await getMyAccountId();
    if (!acc) { alert('ログインが必要です'); return; }

    // 走行時間
    const endedMs = Date.now();
    const duration_s = Math.max(1, ((endedMs - _recStartMs)/1000)|0);
    const distance_m = Math.round(_meters);

    // GeoJSON LineString（[lng,lat]）
    const coords = _track.map(p => [p.lng, p.lat]);
    const gj = { type:'LineString', coordinates: coords };

    // レコード作成
    const payload = {
      account_id: acc,
      started_at: new Date(_recStartMs).toISOString(),
      ended_at:   new Date(endedMs).toISOString(),
      distance_m,
      duration_s,
      geojson: gj,     // polyline は未使用。必要なら後で encode を足せます
      polyline: null
    };

    const { data:newRow, error } = await client.from('runs')
      .insert([payload]).select('id').maybeSingle();

    if (error || !newRow){ console.error(error); alert('保存に失敗しました'); return; }

    // Run 詳細へ遷移（既存UIに合わせて kind=run）
    location.href = `detail.html?id=${encodeURIComponent(newRow.id)}&kind=run&v=${V()}`;

  }catch(e){
    console.error(e);
    alert('保存に失敗しました');
  }finally{
    try{
      _okLayer?.remove(); _okLayer = null;
      _offLayer?.remove(); _offLayer = null;
    }catch(_){}
    const btn = document.getElementById('btnStartRec'); if (btn) btn.disabled = false;
  }
}
</script>

  <footer class="muted" style="margin-top:14px;">v: <script>document.write(window.APP_VERSION)</script></footer>
<script>
  if ('serviceWorker' in navigator) {
    // いったん既存SWを解除してから、バージョン付きURLで登録
    (async () => {
      try {
        const v = window.APP_VERSION || '';
        // 念のため登録前に不要SWを掃除（1度だけでOK）
        const regs = await navigator.serviceWorker.getRegistrations();
        await Promise.all(regs.map(r => r.unregister()));

        const swUrl = `./service-worker.js?v=${encodeURIComponent(v)}`;
        const reg = await navigator.serviceWorker.register(swUrl, { scope: './' });

        // すぐに新SWへ切替
        if (reg.waiting) { reg.waiting.postMessage({ type: 'SKIP_WAITING' }); }
        reg.addEventListener('updatefound', () => {
          const nw = reg.installing;
          if (!nw) return;
          nw.addEventListener('statechange', () => {
            if (nw.state === 'installed' && navigator.serviceWorker.controller) {
              // 新SWが入ったので即時乗り換えを依頼
              reg.waiting?.postMessage({ type: 'SKIP_WAITING' });
            }
          });
        });

        // 明示的にアップデートを促す
        await reg.update();
      } catch (e) {
        console.error('SW register failed', e);
      }
    })();
  }
</script>
</body>
</html>
