<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Detail</title>
  <link rel="icon" href="data:,">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="" />
  <style>
    body { font-family: system-ui,-apple-system,Segoe UI,Roboto; max-width: 920px; margin: 20px auto; padding: 0 12px; color:#111827; }
    .btn { padding:6px 10px; border:1px solid #e5e7eb; border-radius:8px; background:#fff; cursor:pointer; }
    .card { border:1px solid #e5e7eb; border-radius:10px; padding:10px 12px; margin:10px 0; background:#fff; }
    #map { height: 40vh; border:1px solid #e5e7eb; border-radius:10px; }
    .muted{ color:#6b7280; }
    .elev-card { margin-top:12px; border:1px solid #e5e7eb; border-radius:10px; padding:10px 12px; background:#fff; display:none; }
    #elevChart { width:100%; height:140px; display:block; margin-top:8px; }

/* --- 描画モード：地図を実質フルスクリーン化 --- */
body.mode-draw #map { height: calc(var(--vh, 1vh) * 100); }

/* 描画ツールバー（パレット） */
.draw-toolbar{
  position: fixed;
  left: 50%;
  transform: translateX(-50%);
  top: 10px;
  display: flex; gap: 8px; flex-wrap: wrap;
  background: rgba(255,255,255,.96);
  border: 1px solid #e5e7eb; border-radius: 12px;
  padding: 8px 10px;
  box-shadow: 0 2px 12px rgba(0,0,0,.1);
  z-index: 5000;
}
.draw-toolbar .btn { padding:8px 12px; border-radius:10px; }

/* スマホ最適化 */
@media (max-width: 600px) {
  .draw-toolbar{ top: 8px; padding: 10px 12px; }
  .draw-toolbar .btn{ padding: 10px 14px; }
}

/* 既存：閲覧/記録モードの高さ基準（そのまま利用） */
#map { height: 33vh; transition: height .2s ease; }
@media (max-width: 600px) { #map{ height: 30vh; } }
body.mode-record #map { height: calc(var(--vh, 1vh) * 90); }

.rec-overlay {
  position: fixed;
  left: 50%;
  transform: translateX(-50%);
  bottom: 12px;
  display: none; gap: 8px;
  background: rgba(255,255,255,.92);
  border: 1px solid #e5e7eb; border-radius: 12px;
  padding: 8px 10px;
  box-shadow: 0 2px 12px rgba(0,0,0,.08);
  z-index: 5000;
}
.rec-overlay .stat { font-size: 12px; color: #374151; }
.rec-overlay .stat strong { font-size: 14px; }
@media (max-width: 600px) {
  .rec-overlay { bottom: 10px; padding: 10px 12px; }
  .rec-overlay .btn { padding: 10px 14px; border-radius: 12px; }
}

</style>

<script src="js/version.js"></script>

<script>
  const COLORS = {
    routePlanned: '#3b82f6', // 青
    runRecorded:  '#10b981', // 履歴Run表示（緑）
    liveOnRoute:  '#10b981', // 実走オンルート：緑
    liveOffRoute: '#ef4444'  // 実走逸脱：赤
  };
</script>

<script>
  // 1) バージョン管理：変わったらSWもCacheも全消し → 強制再読込
  async function hardRefreshIfVersionChanged() {
    try {
      const v = String(window.APP_VERSION || '');
      const prev = localStorage.getItem('APP_VERSION');
      if (prev && prev !== v) {
        // 既存SWを全部解除
        if ('serviceWorker' in navigator) {
          const regs = await navigator.serviceWorker.getRegistrations();
          await Promise.all(regs.map(r => r.unregister()));
        }
        // 既存Cacheを全削除
        if (window.caches?.keys) {
          const keys = await caches.keys();
          await Promise.all(keys.map(k => caches.delete(k)));
        }
        localStorage.setItem('APP_VERSION', v);
        // ハードリロード
        location.replace(location.pathname + '?v=' + encodeURIComponent(v) + '&t=' + Date.now());
        return;
      }
      localStorage.setItem('APP_VERSION', v);
    } catch (e) { console.warn('hardRefreshIfVersionChanged', e); }
  }

  // 2) すぐ実行（SW登録より先に）
  hardRefreshIfVersionChanged();
</script>
<script>
    if (typeof window.APP_VERSION === 'undefined' || !window.APP_VERSION) {
      window.APP_VERSION = new Date().toISOString().slice(0,10) + '-dev';
    }
  </script>

  <script src="https://unpkg.com/@supabase/supabase-js@2/dist/umd/supabase.js"></script>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
  <script>
    const SUPABASE_URL = "https://cqiqhczxuiyakptdjowr.supabase.co";
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNxaXFoY3p4dWl5YWtwdGRqb3dyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTc3NzAwNzMsImV4cCI6MjA3MzM0NjA3M30.vCFQoQnsClINKa5tQAz-rNnF5XLEukmn_Nl0Err5k3k";
    const client = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY, { auth:{ persistSession:true, autoRefreshToken:true, detectSessionInUrl:false } });
    window.client = client; // デバッグ用に公開

    const V = ()=> encodeURIComponent(window.APP_VERSION||'');
    const $ = (s)=> document.querySelector(s);
    const q = new URL(location.href).searchParams;
    const id = Number(q.get('id'));
    const kind = q.get('kind') || 'run';
    let __map;
    let __currentRoute = null;

    async function getSession(){ const { data:{ session } } = await client.auth.getSession(); return session; }
    async function getMyAccountId(){
      return AuthCommon.getMyAccountId(client);
    }

    function decodePolyline(str){ try{ let idx=0, lat=0, lng=0, arr=[]; while(idx<str.length){ let b,shift=0,result=0; do{ b=str.charCodeAt(idx++)-63; result|=(b&0x1f)<<shift; shift+=5; }while(b>=0x20); let dlat=(result&1)?~(result>>1):(result>>1); shift=0; result=0; do{ b=str.charCodeAt(idx++)-63; result|=(b&0x1f)<<shift; shift+=5; }while(b>=0x20); let dlng=(result&1)?~(result>>1):(result>>1); lat+=dlat; lng+=dlng; arr.push([lat/1e5,lng/1e5]); } return arr; }catch(e){ console.error('decodePolyline', e); return []; } }
    function extractLatLngsFromRoute(route){
      try{
        if (route?.geojson){
          const g = typeof route.geojson==='string' ? JSON.parse(route.geojson) : route.geojson;
          const out = [];
          const walk = (geom)=>{
            if(!geom) return;
            const t = geom.type;
            const co = geom.coordinates;
            if (t==='LineString'){
              co.forEach(([lng,lat])=> out.push({lat,lng}));
            } else if (t==='MultiLineString'){
              co.forEach(line=> line.forEach(([lng,lat])=> out.push({lat,lng})));
            } else if (t==='GeometryCollection'){
              (geom.geometries||[]).forEach(walk);
            }
          };
          if (g.type==='Feature') walk(g.geometry);
          else if (g.type==='FeatureCollection') (g.features||[]).forEach(f=> walk(f.geometry));
          else walk(g);
          if (out.length) return out;
        }
      }catch(e){ console.warn('extract geojson', e); }
      if (route?.polyline){
        return decodePolyline(route.polyline).map(([lat,lng])=>({lat,lng}));
      }
      return [];
    }
    function distancePointToSegmentMeters(p, a, b){
      const latFactor = 111320;
      const lonFactor = 111320 * Math.cos(((a.lat + b.lat) / 2) * Math.PI / 180);
      const ax = a.lng * lonFactor, ay = a.lat * latFactor;
      const bx = b.lng * lonFactor, by = b.lat * latFactor;
      const px = p.lng * lonFactor, py = p.lat * latFactor;
      const vx = bx - ax, vy = by - ay;
      const wx = px - ax, wy = py - ay;
      const c1 = vx * wx + vy * wy;
      const c2 = vx * vx + vy * vy;
      let t = c2 > 0 ? (c1 / c2) : 0;
      t = Math.max(0, Math.min(1, t));
      const sx = ax + t * vx, sy = ay + t * vy;
      const dx = px - sx, dy = py - sy;
      return Math.sqrt(dx * dx + dy * dy);
    }
    function distancePointToPolylineMeters(p, line){
      if (!line || line.length < 2) return Infinity;
      let best = Infinity;
      for (let i = 1; i < line.length; i++){
        const d = distancePointToSegmentMeters(p, line[i-1], line[i]);
        if (d < best) best = d;
      }
      return best;
    }

    const distanceOnEarth = (a, b) => {
      const R = 6371000;
      const toRad = (x) => x * Math.PI / 180;
      const dLat = toRad(b.lat - a.lat);
      const dLng = toRad(b.lng - a.lng);
      const lat1 = toRad(a.lat);
      const lat2 = toRad(b.lat);
      const s = Math.sin(dLat / 2) ** 2 + Math.cos(lat1) * Math.cos(lat2) * Math.sin(dLng / 2) ** 2;
      return 2 * R * Math.asin(Math.sqrt(s));
    };

    const totalDistanceMeters = (points) => {
      if (!Array.isArray(points) || points.length < 2) return 0;
      let sum = 0;
      for (let i = 1; i < points.length; i++) {
        sum += distanceOnEarth(points[i - 1], points[i]);
      }
      return sum;
    };

    const cumDistances = (points) => {
      const out = [0];
      for (let i = 1; i < points.length; i++) {
        out[i] = out[i - 1] + distanceOnEarth(points[i - 1], points[i]);
      }
      return out;
    };

    const samplePoints = (points, maxN = 200) => {
      if (!Array.isArray(points) || points.length === 0) return [];
      if (points.length <= maxN) return points.slice();
      const step = Math.ceil(points.length / maxN);
      const res = [];
      for (let i = 0; i < points.length; i += step) {
        res.push(points[i]);
      }
      if (res[res.length - 1] !== points[points.length - 1]) {
        res.push(points[points.length - 1]);
      }
      return res;
    };

    async function fetchElevations(points) {
      try {
        const samples = samplePoints(points, 200);
        if (!samples.length) return null;
        const qs = samples.map((p) => `${p.lat},${p.lng}`).join('|');
        const url = `https://api.open-elevation.com/api/v1/lookup?locations=${encodeURIComponent(qs)}`;
        const res = await fetch(url, { mode: 'cors' });
        if (!res.ok) return null;
        const json = await res.json();
        const list = json?.results?.map((r) => r.elevation).filter((v) => Number.isFinite(v));
        if (!list || list.length < 2) return null;
        if (points.length <= list.length) return list.slice(0, points.length);
        const expanded = new Array(points.length);
        const step = (points.length - 1) / (list.length - 1);
        for (let i = 0; i < points.length; i++) {
          const pos = i / step;
          const k = Math.floor(pos);
          if (k >= list.length - 1) {
            expanded[i] = list[list.length - 1];
            continue;
          }
          const t = pos - k;
          expanded[i] = list[k] * (1 - t) + list[k + 1] * t;
        }
        return expanded;
      } catch (err) {
        console.warn('fetchElevations failed', err);
        return null;
      }
    }

    const sumGainLoss = (elevs, threshold = 2) => {
      let up = 0;
      let down = 0;
      for (let i = 1; i < elevs.length; i++) {
        const diff = elevs[i] - elevs[i - 1];
        if (diff > threshold) up += diff;
        else if (diff < -threshold) down += -diff;
      }
      return { up: Math.round(up), down: Math.round(down) };
    };

    const smoothElevations = (values, windowSize = 5) => {
      if (!Array.isArray(values) || values.length < 2) return values || [];
      const size = Math.max(1, Math.floor(windowSize));
      if (size <= 1) return values.slice();
      const half = Math.floor(size / 2);
      const smoothed = new Array(values.length);
      for (let i = 0; i < values.length; i++) {
        const start = Math.max(0, i - half);
        const end = Math.min(values.length - 1, i + half);
        let sum = 0;
        let count = 0;
        for (let j = start; j <= end; j++) {
          sum += values[j];
          count++;
        }
        smoothed[i] = count ? sum / count : values[i];
      }
      return smoothed;
    };

    const drawElevationProfile = (svg, elevs, points) => {
      if (!svg) return;
      const ns = 'http://www.w3.org/2000/svg';
      const width = svg.clientWidth || 600;
      const height = svg.clientHeight || 140;
      svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
      while (svg.firstChild) svg.removeChild(svg.firstChild);

      const dists = cumDistances(points);
      const total = dists[dists.length - 1] || 1;
      const minE = Math.min(...elevs);
      const maxE = Math.max(...elevs);
      const range = Math.max(1, maxE - minE);

      const x = (i) => (width * (dists[i] / total));
      const y = (e) => height - ((e - minE) / range) * height;

      const pathArea = document.createElementNS(ns, 'path');
      let d = `M 0 ${height}`;
      for (let i = 0; i < elevs.length; i++) {
        d += ` L ${x(i).toFixed(2)} ${y(elevs[i]).toFixed(2)}`;
      }
      d += ` L ${width} ${height} Z`;
      pathArea.setAttribute('d', d);
      pathArea.setAttribute('fill', '#d1e9ff');
      pathArea.setAttribute('stroke', '#3b82f6');
      pathArea.setAttribute('stroke-width', '1.5');
      svg.appendChild(pathArea);

      const ticks = 4;
      for (let i = 0; i <= ticks; i++) {
        const val = minE + (range * i) / ticks;
        const yy = y(val);
        const line = document.createElementNS(ns, 'line');
        line.setAttribute('x1', 0);
        line.setAttribute('x2', width);
        line.setAttribute('y1', yy);
        line.setAttribute('y2', yy);
        line.setAttribute('stroke', '#f3f4f6');
        svg.appendChild(line);

        const label = document.createElementNS(ns, 'text');
        label.setAttribute('x', 4);
        label.setAttribute('y', Math.max(10, yy - 4));
        label.setAttribute('fill', '#6b7280');
        label.setAttribute('font-size', '10');
        label.textContent = `${Math.round(val)} m`;
        svg.appendChild(label);
      }
    };

    async function renderElevationPanel(points){
      const box = document.getElementById('elevBox');
      const statsEl = document.getElementById('elevStats');
      const chartEl = document.getElementById('elevChart');
      if (!box || !statsEl || !chartEl) return;
      if (!Array.isArray(points) || points.length < 2) {
        box.style.display = 'none';
        return;
      }
      box.style.display = 'block';
      statsEl.textContent = '標高データ取得中…';
      chartEl.innerHTML = '';

      const rawElevs = await fetchElevations(points);
      if (!rawElevs || rawElevs.length < 2) {
        statsEl.textContent = '標高データを取得できませんでした。';
        chartEl.innerHTML = '';
        return;
      }
      const elevs = smoothElevations(rawElevs, rawElevs.length < 7 ? 3 : 5); // 軽い移動平均でギザギザを抑える

      const totalDist = totalDistanceMeters(points);
      const { up, down } = sumGainLoss(elevs, 2);
      const netGain = elevs[elevs.length - 1] - elevs[0];
      const avgGrade = totalDist > 0 ? ((netGain / totalDist) * 100) : 0;
      statsEl.textContent = `総上昇 ${up} m ／ 総下降 ${down} m ／ 平均勾配 ${avgGrade.toFixed(1)} %`;
      drawElevationProfile(chartEl, elevs, points);
    }

    async function renderAuthBar(){
      const bar = $('#authBar');
      try{
        const s = await getSession();
        if(!s?.user){
          bar.innerHTML = `未ログインです。<a class="btn" href="login.html?v=${V()}">ログインへ</a>`;
          return;
        }
        const email = s.user.email || '';
        bar.innerHTML = `
          ログイン中: <strong>${email}</strong>
          <button class="btn" data-signout style="margin-left:8px">サインアウト</button>
          <a class="btn" style="margin-left:6px" href="mypage.html?v=${V()}">マイページへ</a>
          <a class="btn" style="margin-left:6px" href="index.html?v=${V()}">トップへ</a>
        `;
      }catch(e){ bar.textContent='認証状態の取得に失敗しました'; console.error(e); }
    }

    async function loadRun(){
      const box = $('#meta'); const btn = $('#btnToRoute');
      try{
        const { data: run, error } = await client.from('runs').select('id,started_at,ended_at,distance_m,duration_s,polyline,geojson,account_id').eq('id', id).maybeSingle();
        if(error || !run){ box.textContent='読み込み失敗'; console.error(error); return; }
        const when = run.ended_at ? new Date(run.ended_at).toLocaleString() : (run.started_at? new Date(run.started_at).toLocaleString():'-');
        const km = run.distance_m!=null ? (Number(run.distance_m)/1000).toFixed(2)+' km' : '-';
        const min = run.duration_s!=null ? Math.round(Number(run.duration_s)/60)+' 分' : '-';
        box.innerHTML = `<div>日時: ${when}</div><div class=\"muted\">距離: ${km} ・ 時間: ${min}</div>`;
        const mapEl = document.getElementById('map');
        if (__map) {
          __map.remove();
          __map = undefined;
        }
        if (mapEl && mapEl._leaflet_id) {
          mapEl._leaflet_id = null;
          mapEl.innerHTML = '';
        }
        __map = L.map('map').setView([35.68,139.76], 12);
        L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png',{ maxZoom:19, attribution:'&copy; OpenStreetMap' }).addTo(__map);
        drawLineOnMap(__map, run.polyline, run.geojson, COLORS.runRecorded);
        await renderElevationPanel(extractLatLngsFromRoute(run));

        // ルート化ボタン
        btn.style.display='inline-block';
        btn.onclick = async ()=>{
          try{
            const acc = await getMyAccountId(); if(!acc){ alert('ログインが必要です'); return; }
            const ymd = (d=> `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`)(new Date(run.ended_at||run.started_at||Date.now()));
            const payload = { name: `Run ${ymd} のルート`, account_id: acc, is_public: false, route_type: 'from_run', source_run_id: run.id, polyline: run.polyline ?? null, geojson: run.geojson ?? null };
            const { data:newRow, error:e2 } = await client.from('routes').insert([payload]).select('id').maybeSingle();
            if(e2 || !newRow){
              console.error('ROUTE FROM RUN INSERT ERROR', e2, payload);
              alert('作成に失敗: ' + (e2?.message || '不明なエラー'));
              return;
            }
            location.href = `detail.html?id=${encodeURIComponent(newRow.id)}&kind=route&v=${V()}`;
          }catch(e){ console.error(e); alert('作成に失敗'); }
        };
      }catch(e){ box.textContent='読み込み失敗'; console.error(e); }
    }

    async function loadRoute(){
      const box = $('#meta'); const toggleWrap = $('#toggleWrap'); const toggle = $('#visToggle');
      try{
        const { data: route, error } = await client.from('routes')
          .select('*')
          .eq('id', id).maybeSingle();
        if(error || !route){ box.textContent='読み込み失敗'; console.error(error); return; }
        __currentRoute = route;
        const when = route.created_at ? new Date(route.created_at).toLocaleString() : '-';
        const km = route.distance_m != null ? (Number(route.distance_m)/1000).toFixed(2)+' km' : '-';
        const min = route.duration_s != null ? Math.round(Number(route.duration_s)/60)+' 分' : '-';
        const typeBadge = route.route_type === 'from_run' ? 'ログ由来' : (route.route_type || '');
        const pubBadge = route.is_public ? '公開' : '非公開';
        const owner = route.account_id || '-';
        const descBlock = route.description ? `<div class="muted" style="margin-top:4px;">説明: ${route.description}</div>` : '';
        const typeBlock = `
          <div style="margin-top:6px;">
            ${typeBadge ? `<span class=\"muted\" style=\"margin-right:8px;\">[${typeBadge}]</span>` : ''}
            <span class="muted">[${pubBadge}]</span>
          </div>`;
        const ownerBlock = `<div class="muted" style="margin-top:4px;">Owner Account: ${owner}</div>`;
        const sourceBlock = route.source_run_id ? `
          <div style="margin-top:6px;">
            元ログ: <a class="btn" href="detail.html?id=${encodeURIComponent(route.source_run_id)}&kind=run&v=${V()}">Run #${route.source_run_id}</a>
          </div>
        ` : '';
        box.innerHTML = `
          <div style="font-size:18px;font-weight:600;">Route #${route.id}</div>
          <div>名称: <strong>${route.name || '(無題ルート)'}</strong></div>
          <div class="muted">作成日: ${when}</div>
          <div class="muted">距離: ${km} ・ 時間: ${min}</div>
          ${descBlock}
          ${typeBlock}
          ${ownerBlock}
          ${sourceBlock}
        `;
        const mapEl = document.getElementById('map');
        if (__map) {
          __map.remove();
          __map = undefined;
        }
        if (mapEl && mapEl._leaflet_id) {
          mapEl._leaflet_id = null;
          mapEl.innerHTML = '';
        }
        __map = L.map('map').setView([35.68,139.76], 12);
        L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png',{ maxZoom:19, attribution:'&copy; OpenStreetMap' }).addTo(__map);
        drawLineOnMap(__map, route.polyline, route.geojson, COLORS.routePlanned);
        await renderElevationPanel(extractLatLngsFromRoute(route));

        // 自分のものだけトグル表示（ここで失敗してもメタ表示は残す）
        try{
          const acc = await getMyAccountId();
          if(acc && String(acc) === String(route.account_id)){
            toggleWrap.style.display='block';
            toggle.checked = route.is_public === true;
            toggle.onchange = async ()=>{
              try{
                const { error:e3 } = await client.from('routes').update({ is_public: !!toggle.checked }).eq('id', route.id);
                if(e3){ console.error(e3); alert('更新失敗'); toggle.checked = !toggle.checked; }
              }catch(e){ console.error(e); alert('更新失敗'); toggle.checked = !toggle.checked; }
            };
          } else {
            toggleWrap.style.display='none';
          }
        }catch(toggleErr){
          console.warn('owner toggle skipped', toggleErr);
          toggleWrap.style.display='none';
        }
      }catch(e){
        box.textContent='読み込み失敗';
        console.error('loadRoute error', e);
      }

      window.__currentRouteId = route.id;  // ← 保存時に使う
    }

    async function init(){
      await renderAuthBar();
      if(!id){ alert('id が不正です'); return; }
      if(kind==='run') { await loadRun(); }
      else { await loadRoute(); }
      client.auth.onAuthStateChange(async ()=>{ await renderAuthBar(); if(kind==='run') await loadRun(); else await loadRoute(); });
    }
    document.addEventListener('DOMContentLoaded', init, { once:true });
  </script>

<!-- ✅ ここから共通化パート -->
<script src="js/auth-common.js"></script>
<script>
  AuthCommon.init(client, { redirectUrl: 'index.html' });
  window.getMyAccountId = () => AuthCommon.getMyAccountId(client);
</script>

<script>
// --- モバイルvh補正（既に入れていなければ有効化） ---
function setVH(){ document.documentElement.style.setProperty('--vh', (window.innerHeight*0.01)+'px'); }
window.addEventListener('resize', setVH, {passive:true}); setVH();

// === 描画モード 管理 ===
const Draw = {
  active:false,
  pts:[],            // {lat, lng} の配列
  line:null,         // L.Polyline
  markers:[],        // L.CircleMarker[]
  _clickHandler:null
};
function updateDrawLayers(){
  try{
    if (!window.__map) return;
    // 線
    if (!Draw.line){
      Draw.line = L.polyline(Draw.pts, {weight:5}).addTo(__map);
    } else {
      Draw.line.setLatLngs(Draw.pts);
    }
    // マーカー
    Draw.markers.forEach(m=>m.remove());
    Draw.markers = Draw.pts.map(p=> L.circleMarker([p.lat, p.lng], {radius:5, weight:2, fillOpacity:1}).addTo(__map));
    // 表示範囲
    if (Draw.pts.length>=2){
      const b = L.latLngBounds(Draw.pts);
      __map.fitBounds(b, {padding:[20,20], maxZoom:16});
    } else if (Draw.pts.length===1){
      __map.setView(Draw.pts[0], 16);
    }
    // ステータス
    document.getElementById('drawStat').textContent = `点: ${Draw.pts.length} ・ 距離: ${fmtKm(sumDistance(Draw.pts))} km`;
  }catch(e){ console.warn(e); }
}
function fmtKm(m){ return (m/1000).toFixed(2); }
function haversine(a, b){
  const R=6371000, toRad=(x)=>x*Math.PI/180;
  const dLat=toRad(b.lat-a.lat), dLng=toRad(b.lng-a.lng);
  const s1=Math.sin(dLat/2), s2=Math.sin(dLng/2);
  const h=s1*s1 + Math.cos(toRad(a.lat))*Math.cos(toRad(b.lat))*s2*s2;
  return 2*R*Math.asin(Math.sqrt(h));
}
function sumDistance(pts){
  if (pts.length<2) return 0;
  let m=0; for(let i=1;i<pts.length;i++) m += haversine(pts[i-1], pts[i]);
  return m;
}

function enterDrawMode(){
  if (!window.__map){ alert('地図が初期化されていません'); return; }
  document.body.classList.add('mode-draw');
  document.getElementById('drawUI').style.display = 'flex';
  Draw.active = true;
  // 地図クリックで頂点追加
  Draw._clickHandler = (ev)=>{
    Draw.pts.push({ lat: ev.latlng.lat, lng: ev.latlng.lng });
    updateDrawLayers();
  };
  __map.on('click', Draw._clickHandler);
  setTimeout(()=> __map.invalidateSize(true), 220);
}
function exitDrawMode(){
  Draw.active = false;
  document.getElementById('drawUI').style.display = 'none';
  document.body.classList.remove('mode-draw');
  if (Draw._clickHandler && window.__map){ __map.off('click', Draw._clickHandler); }
  Draw._clickHandler = null;
  // レイヤは残してもよいが、通常画面を軽く保つため消去（好みで）
  if (Draw.line){ Draw.line.remove(); Draw.line=null; }
  Draw.markers.forEach(m=>m.remove());
  Draw.markers=[];
  setTimeout(()=> __map.invalidateSize(true), 220);
}

// 操作ボタン
document.getElementById('btnDrawExit').onclick = exitDrawMode;
document.getElementById('btnDrawUndo').onclick = ()=>{ if(Draw.pts.length){ Draw.pts.pop(); updateDrawLayers(); } };
document.getElementById('btnDrawClear').onclick = ()=>{ Draw.pts=[]; updateDrawLayers(); };

// 保存：GeoJSON LineString と距離を routes に保存（polyline は null に）
async function saveDrawnRoute(){
  try{
    if (!window.__currentRouteId){ alert('ルートIDを特定できません'); return; }
    if (Draw.pts.length<2){ alert('少なくとも2点以上が必要です'); return; }
    // GeoJSON（[lng,lat]）
    const coords = Draw.pts.map(p=> [p.lng, p.lat]);
    const gj = { type:'LineString', coordinates: coords };
    const distance_m = Math.round(sumDistance(Draw.pts));
    const payload = { geojson: gj, polyline: null, distance_m };
    const { error } = await window.client.from('routes').update(payload).eq('id', window.__currentRouteId);
    if (error){ console.error(error); alert('保存に失敗しました'); return; }
    alert('保存しました');
    exitDrawMode();
    // 再描画（最新値の反映）
    if (typeof loadRoute === 'function') await loadRoute();
  }catch(e){ console.error(e); alert('保存に失敗しました'); }
}
document.getElementById('btnDrawSave').onclick = saveDrawnRoute;

// ページに「描画モード」開始ボタンを生やす（既存ボタン群の近くに）
document.addEventListener('DOMContentLoaded', ()=>{
  const host = document.querySelector('main .card') || document.querySelector('main');
  const bar = document.createElement('div');
  bar.style.margin = '8px 0';
  // ルート詳細時のみ有効（run では非表示）
  const canDraw = (new URL(location.href).searchParams.get('kind') || 'run') === 'route';
  bar.innerHTML = canDraw ? `<button id="btnStartDraw" class="btn">描画モード</button>` : '';
  if (bar.innerHTML){
    const tgt = document.getElementById('btnToRoute')?.parentElement || host.firstElementChild;
    (tgt?.parentElement || host).insertBefore(bar, tgt);
    document.getElementById('btnStartDraw').onclick = enterDrawMode;
  }
});
</script>

</head>
<body>
  <header class="card" id="authBar"></header>

<main class="card">
    <div id="meta" style="margin-bottom:8px;">読み込み中…</div>
    <div id="toggleWrap" style="display:none; margin:8px 0;">
      <label><input type="checkbox" id="visToggle" /> 公開する</label>
    </div>
    <div style="margin:8px 0;">
      <button id="btnToRoute" class="btn" style="display:none;">このログをルート化する</button>
      <a class="btn" id="btnRunThis" href="#" style="margin-left:6px;">このルートで実走する</a>
      <script>
        (function(){
          const q = new URL(location.href).searchParams;
          const kindParam = q.get('kind');
          if (kindParam !== 'route') { document.getElementById('btnRunThis')?.remove(); return; }
          const rid = q.get('id');
          const a = document.getElementById('btnRunThis');
          if (a && rid) {
            a.href = `run.html?route=${encodeURIComponent(rid)}`;
            a.rel = 'noopener';
          }
        })();
      </script>
    </div>
    <div id="map"></div>
    <div id="elevBox" class="elev-card">
      <div style="font-weight:600;">標高・斜度</div>
      <div id="elevStats" class="muted" style="margin-top:4px;">標高データ取得中…</div>
      <svg id="elevChart"></svg>
    </div>

<!-- 描画モード用 パレット（必要時だけ表示） -->
<div id="drawUI" class="draw-toolbar" style="display:none;">
  <button id="btnDrawExit" class="btn">通常画面に戻る</button>
  <button id="btnDrawUndo" class="btn">取り消し</button>
  <button id="btnDrawClear" class="btn">全消去</button>
  <button id="btnDrawSave" class="btn" style="background:#eef2ff;">保存</button>
  <span class="muted" id="drawStat" style="align-self:center;">点: 0 ・ 距離: 0.00 km</span>
</div>

<!-- 実走記録中にだけ出る小さなオーバーレイUI -->
<div id="recUI" class="rec-overlay">
  <div class="stat">時間: <strong id="recTime">0:00</strong></div>
  <div class="stat">距離: <strong id="recDist">0.00 km</strong></div>
  <button id="btnStopRec" class="btn">停止して保存</button>
</div>

  </main>

<script>
  function drawLineOnMap(map, polyline, geojson, color){
    try{
      const col = color || COLORS.routePlanned;
      if(geojson){
        let gj = typeof geojson==='string'? JSON.parse(geojson): geojson;
        L.geoJSON(gj, { style:{ color: col, weight:5 }}).addTo(map);
        try{ const layer = L.geoJSON(gj); map.fitBounds(layer.getBounds(), { padding:[20,20], maxZoom:16 }); }catch(_){}
        return;
      }
      if(polyline){
        const latlngs = decodePolyline(polyline);
        if(latlngs.length){
          const line = L.polyline(latlngs,{ color: col, weight:5 }).addTo(map);
          map.fitBounds(line.getBounds(),{ padding:[20,20], maxZoom:16 });
        }
      }
    }catch(e){ console.error('draw error', e); }
  }
</script>

<script>
// ==== 実走記録（Run 作成） ====
// 依存: window.client（Supabase）, getMyAccountId(), __map（Leaflet）

// 状態
let _watchId = null, _timerId = null;
let _recStartMs = 0;
let _track = [];             // 全点（保存用）
let _meters = 0;
let _okLayer = null;         // 緑（オンルート）
let _offLayer = null;        // 赤（逸脱）
let _lastP = null;
let _planned = [];           // 予定ルートの座標配列（kind=route 時のみセット）
const OFF_THRESHOLD_M = 30;  // 逸脱判定の閾値（お好みで 20〜50m）

function fmtMinSec(sec){ const m = Math.floor(sec/60), s = sec%60|0; return `${m}:${String(s).padStart(2,'0')}`; }
function fmtKm(m){ return (m/1000).toFixed(2); }
function haversine(a,b){
  const R=6371000, toRad=x=>x*Math.PI/180;
  const dLat=toRad(b.lat-a.lat), dLng=toRad(b.lng-a.lng);
  const s1=Math.sin(dLat/2), s2=Math.sin(dLng/2);
  const h=s1*s1 + Math.cos(toRad(a.lat))*Math.cos(toRad(b.lat))*s2*s2;
  return 2*R*Math.asin(Math.sqrt(h));
}

function showRecUI(show){ document.getElementById('recUI').style.display = show ? 'flex' : 'none'; }

// 実走開始
async function startRunRecording(){
  const acc = await getMyAccountId();
  if (!acc) { alert('ログインが必要です'); return; }
  if (!navigator.geolocation) { alert('この端末は位置情報に対応していません'); return; }

  _track = []; _meters = 0; _lastP = null; _recStartMs = Date.now();
  document.getElementById('recTime').textContent = '0:00';
  document.getElementById('recDist').textContent = '0.00 km';
  showRecUI(true);

  if (!__map){
    alert('地図の初期化が完了していません。少し待ってから再度お試しください。');
    showRecUI(false);
    return;
  }

  _planned = [];
  // 予定ルート（kind=routeの時だけ取得）
  try{
    const q = new URL(location.href).searchParams;
    const kind = (q.get('kind')||'run');
    if (kind === 'route') {
      if (__currentRoute){
        _planned = extractLatLngsFromRoute(__currentRoute) || [];
      } else {
        const id = Number(q.get('id'));
        const { data: route } = await client.from('routes').select('*').eq('id', id).maybeSingle();
        _planned = route ? extractLatLngsFromRoute(route) : [];
      }
    } else {
      _planned = [];
    }
  }catch(e){ console.warn('planned fetch', e); }

  // 地図レイヤ初期化（緑／赤）
  try{
    if (_okLayer){ _okLayer.remove(); _okLayer = null; }
    if (_offLayer){ _offLayer.remove(); _offLayer = null; }
    _okLayer  = L.polyline([], { color: COLORS.liveOnRoute,  weight:5 }).addTo(__map);
    _offLayer = L.polyline([], { color: COLORS.liveOffRoute, weight:5 }).addTo(__map);
  }catch(e){ console.warn(e); }

  _timerId = setInterval(()=>{
    const sec = ((Date.now()-_recStartMs)/1000)|0;
    document.getElementById('recTime').textContent = fmtMinSec(sec);
    document.getElementById('recDist').textContent = `${fmtKm(_meters)} km`;
  }, 1000);

  _watchId = navigator.geolocation.watchPosition(onPos, onPosError, {
    enableHighAccuracy:true, maximumAge:1000, timeout:10000
  });

  const btn = document.getElementById('btnStartRec'); if (btn) btn.disabled = true;
}

function onPosError(err){ console.warn('geo error', err); }

// 位置更新
function onPos(pos){
  const p = { lat: pos.coords.latitude, lng: pos.coords.longitude, ts: Date.now(), acc: pos.coords.accuracy||0 };

  if (p.acc && p.acc > 50) return;

  if (!_lastP){
    _track.push(p);
    _lastP = p;
    if (__map) __map.setView([p.lat, p.lng], 16);
    pushToLiveLayer(p);
    return;
  }

  const d = haversine(_lastP, p);
  if (d < 10) return;

  _meters += d;
  _track.push(p);
  _lastP = p;

  pushToLiveLayer(p);

  try{
    if (__map) __map.panTo([p.lat, p.lng], { animate:false });
  }catch(e){ console.warn(e); }
}

// 予定ルートへの距離で緑/赤に振り分け
function pushToLiveLayer(p){
  try{
    if (_planned && _planned.length >= 2){
      const dist = distancePointToPolylineMeters(p, _planned);
      if (dist <= OFF_THRESHOLD_M){
        _okLayer?.addLatLng?.([p.lat, p.lng]);
      } else {
        _offLayer?.addLatLng?.([p.lat, p.lng]);
      }
    } else {
      _okLayer?.addLatLng?.([p.lat, p.lng]);
    }
  }catch(e){ console.warn(e); }
}

// 停止＆保存
async function stopRunRecordingAndSave(){
  try{
    if (_watchId!=null){ navigator.geolocation.clearWatch(_watchId); _watchId = null; }
    if (_timerId!=null){ clearInterval(_timerId); _timerId = null; }
    showRecUI(false);

    // 記録が短すぎる場合
    if (_track.length < 2) { alert('記録が短すぎます（2点以上必要）'); return; }

    const acc = await getMyAccountId();
    if (!acc) { alert('ログインが必要です'); return; }

    // 走行時間
    const endedMs = Date.now();
    const duration_s = Math.max(1, ((endedMs - _recStartMs)/1000)|0);
    const distance_m = Math.round(_meters);

    // GeoJSON LineString（[lng,lat]）
    const coords = _track.map(p => [p.lng, p.lat]);
    const gj = { type:'LineString', coordinates: coords };

    // レコード作成
    const payload = {
      account_id: acc,
      started_at: new Date(_recStartMs).toISOString(),
      ended_at:   new Date(endedMs).toISOString(),
      distance_m,
      duration_s,
      geojson: gj,     // polyline は未使用。必要なら後で encode を足せます
      polyline: null
    };

    const { data:newRow, error } = await client.from('runs')
      .insert([payload]).select('id').maybeSingle();

    if (error || !newRow){ console.error(error); alert('保存に失敗しました'); return; }

    // Run 詳細へ遷移（既存UIに合わせて kind=run）
    location.href = `detail.html?id=${encodeURIComponent(newRow.id)}&kind=run&v=${V()}`;

  }catch(e){
    console.error(e);
    alert('保存に失敗しました');
  }finally{
    try{
      _okLayer?.remove(); _okLayer = null;
      _offLayer?.remove(); _offLayer = null;
    }catch(_){}
    const btn = document.getElementById('btnStartRec'); if (btn) btn.disabled = false;
  }
}
</script>

  <footer class="muted" style="margin-top:14px;">v: <script>document.write(window.APP_VERSION)</script></footer>
<script>
  if ('serviceWorker' in navigator) {
    // いったん既存SWを解除してから、バージョン付きURLで登録
    (async () => {
      try {
        const v = window.APP_VERSION || '';
        // 念のため登録前に不要SWを掃除（1度だけでOK）
        const regs = await navigator.serviceWorker.getRegistrations();
        await Promise.all(regs.map(r => r.unregister()));

        const swUrl = `./service-worker.js?v=${encodeURIComponent(v)}`;
        const reg = await navigator.serviceWorker.register(swUrl, { scope: './' });

        // すぐに新SWへ切替
        if (reg.waiting) { reg.waiting.postMessage({ type: 'SKIP_WAITING' }); }
        reg.addEventListener('updatefound', () => {
          const nw = reg.installing;
          if (!nw) return;
          nw.addEventListener('statechange', () => {
            if (nw.state === 'installed' && navigator.serviceWorker.controller) {
              // 新SWが入ったので即時乗り換えを依頼
              reg.waiting?.postMessage({ type: 'SKIP_WAITING' });
            }
          });
        });

        // 明示的にアップデートを促す
        await reg.update();
      } catch (e) {
        console.error('SW register failed', e);
      }
    })();
  }
</script>
</body>
</html>
