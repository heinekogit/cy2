<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Route Editor</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="" />
  <style>
    :root {
      color-scheme: light;
      --bg: #f9fafb;
      --fg: #111827;
      --accent: #3b82f6;
    }
    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      height: 100%;
      background: var(--bg);
      color: var(--fg);
      font-family: system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue","Noto Sans JP",sans-serif;
      overscroll-behavior: none;
    }
    #map {
      position: fixed;
      inset: 0;
      z-index: 0;
    }
    header {
      position: fixed;
      top: env(safe-area-inset-top, 8px);
      left: 8px;
      right: 8px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      border-radius: 12px;
      background: rgba(255,255,255,0.92);
      box-shadow: 0 4px 18px rgba(15,23,42,0.1);
      backdrop-filter: blur(6px);
      z-index: 10;
      flex-wrap: wrap;
    }
    #toolbar {
      position: fixed;
      bottom: env(safe-area-inset-bottom, 12px);
      left: 8px;
      right: 8px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      padding: 8px;
      border-radius: 14px;
      background: rgba(255,255,255,0.92);
      box-shadow: 0 8px 24px rgba(15,23,42,0.12);
      backdrop-filter: blur(6px);
      z-index: 10;
      justify-content: center;
    }
    .btn {
      border: 1px solid #d1d5db;
      border-radius: 10px;
      padding: 8px 10px;
      font-size: 14px;
      background: #fff;
      color: #111827;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
      min-width: 36px;
      text-decoration: none;
    }
    .btn.primary {
      background: var(--accent);
      border-color: var(--accent);
      color: #fff;
    }
    .btn.danger {
      background: #ef4444;
      border-color: #ef4444;
      color: #fff;
    }
    .btn.active {
      border-color: var(--accent);
      color: var(--accent);
      background: rgba(59,130,246,0.12);
    }
    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    select.mode-select {
      padding: 8px 10px;
      border: 1px solid #d1d5db;
      border-radius: 10px;
      background: #fff;
      color: #111827;
      font-size: 14px;
      min-width: 140px;
    }
    #statusToast {
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      bottom: calc(env(safe-area-inset-bottom,12px) + 64px);
      background: rgba(17,24,39,0.92);
      color: #fff;
      padding: 8px 12px;
      border-radius: 10px;
      font-size: 13px;
      display: none;
      z-index: 20;
    }
    #nameField {
      flex: 1 1 auto;
      display: flex;
      gap: 8px;
      align-items: center;
      min-width: 0;
    }
    #routeName {
      flex: 1;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid #d1d5db;
      background: #fff;
      font-size: 14px;
      min-width: 160px;
    }
    #authNotice {
      font-size: 13px;
      color: #b91c1c;
    }
    @media (max-width: 600px) {
      header { flex-direction: column; align-items: stretch; }
      #toolbar { justify-content: center; }
    }
  </style>

  <script src="js/version.js"></script>
  <script>
    if (typeof window.APP_VERSION === 'undefined' || !window.APP_VERSION) {
      window.APP_VERSION = new Date().toISOString().slice(0, 10) + '-dev';
    }
  </script>
  <script src="https://unpkg.com/@supabase/supabase-js@2/dist/umd/supabase.js"></script>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
</head>
<body>
  <div id="map"></div>
  <header>
    <div id="nameField">
      <input id="routeName" type="text" placeholder="ルート名称 (任意)" />
      <div id="authNotice"></div>
    </div>
    <div style="display:flex; gap:8px; flex-wrap:wrap;">
      <button id="btnBack" class="btn">戻る</button>
      <button id="btnSave" class="btn primary">保存</button>
    </div>
  </header>

  <div id="toolbar">
    <select id="modeSelect" class="mode-select">
      <option value="cycling">自転車モード</option>
      <option value="walking">徒歩モード</option>
      <option value="driving">車モード</option>
    </select>
    <button data-tool="add" class="btn active">追加</button>
    <button data-tool="move" class="btn">移動</button>
    <button data-tool="delete" class="btn">削除</button>
    <button id="btnUndo" class="btn">Undo</button>
    <button id="btnRedo" class="btn">Redo</button>
    <button id="btnClear" class="btn danger">クリア</button>
  </div>

  <div id="statusToast"></div>

  <script src="js/auth-common.js"></script>
  <script src="js/config.js"></script>
  <script type="module">
    import { routing } from './js/routing.js';

    const SUPABASE_URL = "https://cqiqhczxuiyakptdjowr.supabase.co";
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNxaXFoY3p4dWl5YWtwdGRqb3dyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTc3NzAwNzMsImV4cCI6MjA3MzM0NjA3M30.vCFQoQnsClINKa5tQAz-rNnF5XLEukmn_Nl0Err5k3k";
    const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
      auth:{ persistSession:true, autoRefreshToken:true, detectSessionInUrl:false }
    });
    window.supabaseClient = supabase;
    window.supabase = supabase;

    AuthCommon.init(supabase, { redirectUrl: 'index.html' });
    window.getMyAccountId = () => AuthCommon.getMyAccountId(supabase);

    const V = () => encodeURIComponent(window.APP_VERSION || '');
    const q = new URL(location.href).searchParams;
    const editingId = q.get('id') ? Number(q.get('id')) : null;

    const map = L.map('map', {
      zoomControl: true,
      attributionControl: true
    }).setView([35.681236, 139.767125], 13);
    L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    const polylineLayer = L.polyline([], { color: '#3b82f6', weight: 5 }).addTo(map);
    let controlMarkers = [];

    const routeNameInput = document.getElementById('routeName');
    const authNotice = document.getElementById('authNotice');
    const btnSave = document.getElementById('btnSave');
    const btnBack = document.getElementById('btnBack');
    const btnUndo = document.getElementById('btnUndo');
    const btnRedo = document.getElementById('btnRedo');
    const btnClear = document.getElementById('btnClear');
    const toolbar = document.getElementById('toolbar');
    const modeSelect = document.getElementById('modeSelect');
    const toast = document.getElementById('statusToast');

    const STORAGE_KEY = 'route-draft';

    const state = {
      controlPoints: [],
      routeLine: [],
      history: [],
      future: [],
      tool: 'add',
      dirty: false,
      accountId: null,
      loggedIn: false,
      mode: modeSelect.value || 'cycling',
      currentRoute: null,
      routeBuildQueue: Promise.resolve(),
      draftTimer: null
    };

    const clonePoint = (p) => ({ lat: Number(p.lat), lng: Number(p.lng) });

    function showToast(msg, ms = 2000) {
      toast.textContent = msg;
      toast.style.display = 'block';
      setTimeout(() => { toast.style.display = 'none'; }, ms);
    }

    const setDirty = (flag) => { state.dirty = flag; };

    function scheduleDraftSave() {
      if (state.draftTimer) clearTimeout(state.draftTimer);
      state.draftTimer = setTimeout(() => {
        try {
          const payload = {
            name: routeNameInput.value || '',
            controlPoints: state.controlPoints,
            routeLine: state.routeLine,
            mode: state.mode,
            routeId: editingId || null,
            updatedAt: Date.now()
          };
          localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
        } catch (e) {
          console.warn('draft save failed', e);
        }
      }, 5000);
    }

    function encodePolyline(points) {
      try {
        let lastLat = 0;
        let lastLng = 0;
        let enc = '';
        const e5 = (n) => Math.round(n * 1e5);
        const push = (v) => {
          v = v < 0 ? ~(v << 1) : (v << 1);
          while (v >= 0x20) {
            enc += String.fromCharCode((0x20 | (v & 0x1f)) + 63);
            v >>= 5;
          }
          enc += String.fromCharCode(v + 63);
        };
        for (const p of points) {
          const la = e5(p.lat);
          const ln = e5(p.lng);
          push(la - lastLat);
          push(ln - lastLng);
          lastLat = la;
          lastLng = ln;
        }
        return enc;
      } catch (e) {
        console.warn('encodePolyline failed', e);
        return '';
      }
    }

    const currentSnapshot = () => JSON.stringify({
      control: state.controlPoints,
      route: state.routeLine,
      mode: state.mode
    });

    function applySnapshot(json) {
      const data = JSON.parse(json || '{}');
      state.controlPoints = Array.isArray(data.control) ? data.control.map(clonePoint) : [];
      state.routeLine = Array.isArray(data.route) && data.route.length
        ? data.route.map(clonePoint)
        : state.controlPoints.map(clonePoint);
      if (data.mode) {
        setMode(data.mode, { skipRebuild: true, skipHistory: true });
      }
      updatePolyline({ fit: false });
      updateMarkers();
    }

    function pushHistory() {
      const snap = currentSnapshot();
      const last = state.history[state.history.length - 1];
      if (last === snap) return;
      state.history.push(snap);
      if (state.history.length > 100) state.history.shift();
      state.future = [];
    }

    function updatePolyline({ fit = true } = {}) {
      polylineLayer.setLatLngs(state.routeLine.map(p => [p.lat, p.lng]));
      if (fit && state.routeLine.length >= 2) {
        try {
          map.fitBounds(polylineLayer.getBounds(), { padding: [30, 30], maxZoom: 16 });
        } catch (_) {}
      }
    }

    function clearMarkers() {
      controlMarkers.forEach(m => m.remove());
      controlMarkers = [];
    }

    function updateMarkers() {
      clearMarkers();
      state.controlPoints.forEach((p, idx) => {
        const marker = L.marker([p.lat, p.lng], {
          draggable: state.tool === 'move',
          icon: L.divIcon({
            className: 'point-marker',
            html: `<div style="width:14px;height:14px;border-radius:50%;border:2px solid #fff;background:${state.tool==='delete' ? '#ef4444' : '#3b82f6'};box-shadow:0 1px 4px rgba(0,0,0,.25);"></div>`,
            iconSize: [14, 14],
            iconAnchor: [7, 7]
          })
        }).addTo(map);
        marker.on('dragend', ev => {
          if (state.tool !== 'move') {
            marker.setLatLng([p.lat, p.lng]);
            return;
          }
          const { lat, lng } = ev.target.getLatLng();
          state.controlPoints[idx] = { lat, lng };
          commitControlChange().catch(err => console.error(err));
        });
        marker.on('click', () => {
          if (state.tool === 'delete') {
            removeControlPoint(idx).catch(err => console.error(err));
          }
        });
        controlMarkers.push(marker);
      });
      controlMarkers.forEach(marker => {
        if (state.tool === 'move') marker.dragging.enable();
        else marker.dragging.disable();
      });
    }

    function setTool(tool) {
      state.tool = tool;
      toolbar.querySelectorAll('[data-tool]').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.tool === tool);
      });
      updateMarkers();
    }

    const directSegment = (a, b) => [{ lat: a.lat, lng: a.lng }, { lat: b.lat, lng: b.lng }];

    function rebuildRouteLine() {
      state.routeBuildQueue = state.routeBuildQueue.then(async () => {
        const ctrl = state.controlPoints.map(clonePoint);
        if (ctrl.length === 0) {
          state.routeLine = [];
          updatePolyline({ fit: false });
          updateMarkers();
          return;
        }
        if (ctrl.length === 1) {
          state.routeLine = [ctrl[0]];
          updatePolyline({ fit: false });
          updateMarkers();
          return;
        }
        showToast('ルート計算中…', 1200);
        let assembled = [{ lat: ctrl[0].lat, lng: ctrl[0].lng }];
        for (let i = 0; i < ctrl.length - 1; i++) {
          const a = ctrl[i];
          const b = ctrl[i + 1];
          try {
            const { geojson } = await routing.getRoute([a, b], state.mode);
            let segment = geojson.coordinates.map(([lng, lat]) => ({ lat, lng }));
            if (segment.length) {
              if (assembled.length) segment.shift();
              assembled = assembled.concat(segment);
            }
          } catch (err) {
            console.warn('routing segment failed', err);
            let fallback = directSegment(a, b);
            if (assembled.length) fallback.shift();
            assembled = assembled.concat(fallback);
          }
        }
        state.routeLine = assembled;
        updatePolyline({ fit: true });
        updateMarkers();
      }).catch(err => {
        console.error('rebuildRouteLine failed', err);
      });
      return state.routeBuildQueue;
    }

    async function commitControlChange({ skipHistory = false } = {}) {
      await rebuildRouteLine();
      if (!skipHistory) {
        pushHistory();
        setDirty(true);
      }
      scheduleDraftSave();
    }

    async function addControlPoint(lat, lng) {
      if (!state.loggedIn) {
        showToast('ログインして編集してください');
        return;
      }
      state.controlPoints.push({ lat, lng });
      await commitControlChange();
    }

    async function removeControlPoint(idx) {
      if (idx < 0 || idx >= state.controlPoints.length) return;
      state.controlPoints.splice(idx, 1);
      await commitControlChange();
    }

    async function clearAll() {
      if (!state.controlPoints.length) return;
      if (!confirm('すべてのポイントを削除しますか？')) return;
      state.controlPoints = [];
      state.routeLine = [];
      updatePolyline({ fit: false });
      updateMarkers();
      pushHistory();
      setDirty(true);
      scheduleDraftSave();
    }

    function undo() {
      if (state.history.length <= 1) return;
      const current = state.history.pop();
      state.future.push(current);
      const prev = state.history[state.history.length - 1];
      applySnapshot(prev);
      setDirty(true);
      scheduleDraftSave();
    }

    function redo() {
      if (!state.future.length) return;
      const snap = state.future.pop();
      state.history.push(snap);
      applySnapshot(snap);
      setDirty(true);
      scheduleDraftSave();
    }

    function deriveControlPointsFromRoute(routeLine) {
      const pts = routeLine.map(clonePoint);
      if (pts.length <= 2) return pts;
      const maxPoints = 40;
      const step = Math.max(1, Math.ceil(pts.length / maxPoints));
      const res = [];
      for (let i = 0; i < pts.length; i += step) {
        res.push(pts[i]);
      }
      const last = pts[pts.length - 1];
      const tail = res[res.length - 1];
      if (!tail || tail.lat !== last.lat || tail.lng !== last.lng) {
        res.push(last);
      }
      if (res.length === 1 && pts.length >= 2) {
        res.push(last);
      }
      return res;
    }

    function routingPolylineToLatLng(str) {
      try {
        let index = 0;
        let lat = 0;
        let lng = 0;
        const coords = [];
        while (index < str.length) {
          let b;
          let shift = 0;
          let result = 0;
          do {
            b = str.charCodeAt(index++) - 63;
            result |= (b & 0x1f) << shift;
            shift += 5;
          } while (b >= 0x20);
          const dlat = (result & 1) ? ~(result >> 1) : (result >> 1);
          lat += dlat;
          shift = 0;
          result = 0;
          do {
            b = str.charCodeAt(index++) - 63;
            result |= (b & 0x1f) << shift;
            shift += 5;
          } while (b >= 0x20);
          const dlng = (result & 1) ? ~(result >> 1) : (result >> 1);
          lng += dlng;
          coords.push({ lat: lat * 1e-5, lng: lng * 1e-5 });
        }
        return coords;
      } catch (e) {
        console.warn('decode polyline failed', e);
        return [];
      }
    }

    async function loadRoute(routeId) {
      try {
        const { data, error } = await supabase
          .from('routes')
          .select('*')
          .eq('id', routeId)
          .maybeSingle();
        if (error || !data) {
          showToast('ルートの読み込みに失敗しました');
          return;
        }
        state.currentRoute = data;
        routeNameInput.value = data.name || '';
        let routeLine = [];
        if (data.geojson) {
          try {
            const g = typeof data.geojson === 'string' ? JSON.parse(data.geojson) : data.geojson;
            routeLine = (g?.coordinates || []).map(([lng, lat]) => ({ lat, lng }));
          } catch (e) {
            console.warn('geojson parse failed', e);
          }
        }
        if (!routeLine.length && data.polyline) {
          routeLine = routingPolylineToLatLng(data.polyline);
        }
        state.routeLine = routeLine;
        updatePolyline({ fit: true });
        state.controlPoints = deriveControlPointsFromRoute(routeLine);
        updateMarkers();
        state.history = [currentSnapshot()];
        state.future = [];
        setDirty(false);
      } catch (e) {
        console.error(e);
        showToast('ルートの読み込みに失敗しました');
      }
    }

    async function restoreDraftIfNeeded() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return;
        const draft = JSON.parse(raw);
        if (!draft || !Array.isArray(draft.controlPoints) || !draft.controlPoints.length) return;
        if (editingId && draft.routeId && Number(draft.routeId) !== editingId) return;
        if (!confirm('以前保存されたドラフトがあります。復元しますか？')) return;
        routeNameInput.value = draft.name || '';
        if (draft.mode) {
          state.mode = draft.mode;
          modeSelect.value = draft.mode;
        }
        state.controlPoints = draft.controlPoints.map(clonePoint);
        state.routeLine = Array.isArray(draft.routeLine) && draft.routeLine.length
          ? draft.routeLine.map(clonePoint)
          : state.controlPoints.map(clonePoint);
        updatePolyline({ fit: true });
        updateMarkers();
        state.history = [currentSnapshot()];
        state.future = [];
        setDirty(true);
      } catch (e) {
        console.warn('restore draft failed', e);
      }
    }

    async function refreshAuth() {
      try {
        const { data:{ session } } = await supabase.auth.getSession();
        state.loggedIn = !!session?.user;
        if (!state.loggedIn) {
          authNotice.textContent = 'ログインして編集してください';
          state.accountId = null;
          btnSave.disabled = true;
          modeSelect.disabled = true;
          toolbar.querySelectorAll('button').forEach(btn => {
            if (btn !== btnBack) btn.disabled = true;
          });
        } else {
          authNotice.textContent = '';
          btnSave.disabled = false;
          modeSelect.disabled = false;
          toolbar.querySelectorAll('button').forEach(btn => btn.disabled = false);
          state.accountId = await getMyAccountId();
          if (!state.accountId) {
            authNotice.textContent = 'アカウント情報を取得できません（再ログインしてください）';
            btnSave.disabled = true;
          }
        }
      } catch (e) {
        console.warn('auth refresh failed', e);
      }
    }

    async function setMode(mode, { skipRebuild = false, skipHistory = false } = {}) {
      state.mode = mode;
      if (modeSelect.value !== mode) modeSelect.value = mode;
      if (skipRebuild) return;
      if (state.controlPoints.length >= 2) {
        await commitControlChange({ skipHistory });
      }
      scheduleDraftSave();
    }

    async function saveRoute() {
      if (!state.loggedIn || !state.accountId) {
        alert('保存にはログインが必要です');
        return;
      }
      if (state.routeLine.length < 2) {
        alert('少なくとも2点以上のポイントが必要です');
        return;
      }
      const coordsLngLat = state.routeLine.map(p => [p.lng, p.lat]);
      const geojson = { type: 'LineString', coordinates: coordsLngLat };
      const polylineStr = encodePolyline(state.routeLine);
      const name = routeNameInput.value.trim() || '新しいルート';
      const now = new Date().toISOString();
      const payload = {
        name,
        geojson,
        polyline: polylineStr,
        account_id: state.accountId,
        owner_account_id: state.accountId,
        updated_at: now
      };
      if (!editingId) {
        payload.created_at = now;
        payload.is_public = false;
        payload.route_type = 'editor';
      }
      btnSave.disabled = true;
      showToast('保存中…', 1200);
      try {
        let result;
        if (editingId) {
          result = await supabase
            .from('routes')
            .update(payload)
            .eq('id', editingId)
            .select('id')
            .maybeSingle();
        } else {
          result = await supabase
            .from('routes')
            .insert([payload])
            .select('id')
            .maybeSingle();
        }
        const { data, error, status } = result;
        if (error || !data?.id) {
          console.error('ROUTE SAVE ERROR', { status, error, payload });
          alert(`保存に失敗: ${status || ''} ${error?.message || ''}`);
          return;
        }
        setDirty(false);
        localStorage.removeItem(STORAGE_KEY);
        location.replace(`detail.html?id=${encodeURIComponent(data.id)}&kind=route&v=${V()}`);
      } catch (e) {
        console.error('ROUTE SAVE EXCEPTION', e);
        alert('保存に失敗: ' + (e?.message || '不明なエラー'));
      } finally {
        btnSave.disabled = false;
      }
    }

    toolbar.querySelectorAll('[data-tool]').forEach(btn => {
      btn.addEventListener('click', () => setTool(btn.dataset.tool));
    });
    btnUndo.addEventListener('click', () => undo());
    btnRedo.addEventListener('click', () => redo());
    btnClear.addEventListener('click', () => { clearAll().catch(err => console.error(err)); });
    btnSave.addEventListener('click', () => { saveRoute().catch(err => console.error(err)); });
    btnBack.addEventListener('click', () => {
      if (state.dirty && !confirm('変更が保存されていません。戻りますか？')) return;
      history.back();
    });
    routeNameInput.addEventListener('input', () => {
      setDirty(true);
      scheduleDraftSave();
    });
    modeSelect.addEventListener('change', () => {
      setMode(modeSelect.value).catch(err => console.error(err));
    });

    map.on('click', ev => {
      if (state.tool !== 'add') return;
      addControlPoint(ev.latlng.lat, ev.latlng.lng).catch(err => console.error(err));
    });

    refreshAuth();
    supabase.auth.onAuthStateChange(async () => { await refreshAuth(); });
    window.addEventListener('beforeunload', (e) => {
      if (!state.dirty) return;
      e.preventDefault();
      e.returnValue = '';
    });

    async function init() {
      if (editingId) {
        await loadRoute(editingId);
      } else {
        await restoreDraftIfNeeded();
      }
      if (!state.history.length) {
        state.history = [currentSnapshot()];
      }
      updateMarkers();
      map.whenReady(() => map.invalidateSize());
    }

    init().catch(err => console.error(err));
  </script>
</body>
</html>
