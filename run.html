<!doctype html>
<html lang="ja">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Route MVP â€“ å®Ÿèµ°è¨˜éŒ²</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="" />
  <script src="js/version.js"></script>
  <script>
    if (typeof window.APP_VERSION === 'undefined' || !window.APP_VERSION) {
      window.APP_VERSION = new Date().toISOString().slice(0, 10) + '-dev';
    }
  </script>
  <style>
    :root {
      --bg: #fff;
      --fg: #111827;
      --muted: #6b7280;
      --accent: #111827;
      --ok: #065f46;
      --okbg: #d1fae5;
      --warn: #92400e;
      --warnbg: #fef3c7;
      --off: #991b1b;
      --offbg: #fee2e2;
    }

    html,
    body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: var(--fg);
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans JP";
    }

    #app {
      height: 100%;
      display: flex;
      flex-direction: column;
    }

    header {
      padding: 10px 12px;
      border-bottom: 1px solid #e5e7eb;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }

    header .tabs {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .tab {
      padding: 8px 12px;
      border-radius: 999px;
      border: 1px solid #e5e7eb;
      cursor: pointer;
      background: #fff;
    }

    .tab.active {
      background: #111827;
      color: #fff;
      border-color: #111827;
    }

    .btn {
      border: none;
      border-radius: 10px;
      padding: 8px 10px;
      font-size: 14px;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
      text-decoration: none;
    }

    .btn.ghost {
      background: #fff;
      color: #111827;
      border: 1px solid #e5e7eb;
    }

    .btn.primary {
      background: #111827;
      color: #fff;
    }

    .btn.danger {
      background: #ef4444;
      color: #fff;
    }

    .btn.big {
      padding: 12px 14px;
      font-weight: 700;
    }

    main {
      flex: 1;
      display: flex;
    }

    .panel {
      flex: 1;
      display: none;
    }

    .panel.active {
      display: flex;
    }

    #logsSection {
      flex-direction: column;
    }

    .list {
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      overflow: auto;
    }

    .card {
      border: 1px solid #e5e7eb;
      border-radius: 12px;
      padding: 10px 12px;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 12px;
      background: #fff;
    }

    .card.highlight {
      outline: 3px solid #93c5fd;
    }

    .meta {
      font-size: 12px;
      color: var(--muted);
    }

    #runSection {
      position: relative;
      display: none;
    }

    #runSection.active {
      display: block;
    }

    #map {
      position: absolute;
      inset: 0;
    }

    .badgewrap {
      position: fixed;
      left: 8px;
      right: 8px;
      top: env(safe-area-inset-top, 8px);
      display: flex;
      gap: 8px;
      z-index: 1000;
    }

    .badge {
      padding: 6px 10px;
      border-radius: 999px;
      font-weight: 600;
      background: #e2e8f0;
    }

    .badge.ok {
      background: var(--okbg);
      color: var(--ok);
    }

    .badge.warn {
      background: var(--warnbg);
      color: var(--warn);
    }

    .badge.off {
      background: var(--offbg);
      color: var(--off);
    }

    .dock {
      position: fixed;
      right: 8px;
      bottom: 8px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      z-index: 1100;
      /* ãƒœã‚¿ãƒ³ã‚’æœ€å‰é¢ã« */
      pointer-events: auto;
    }

    .toolbar {
      position: fixed;
      left: 8px;
      bottom: 8px;
      z-index: 1000;
      display: flex;
      gap: 8px;
    }

    .route-photo-upload {
      position: fixed;
      left: 8px;
      bottom: 110px;
      background: rgba(255, 255, 255, 0.92);
      border: 1px solid #e5e7eb;
      border-radius: 999px;
      padding: 6px 12px;
      font-size: 14px;
      display: flex;
      flex-direction: column;
      gap: 4px;
      z-index: 900;
      /* ãƒœã‚¿ãƒ³ã‚ˆã‚ŠèƒŒé¢ã¸ */
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
    }

    .route-photo-upload label {
      cursor: pointer;
      display: block;
      align-items: center;
      gap: 6px;
      font-weight: 600;
    }

    #route-photo-upload-status {
      font-size: 12px;
      color: #6b7280;
    }

    .toast {
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      bottom: 20px;
      background: #111827;
      color: #fff;
      padding: 10px 14px;
      border-radius: 10px;
      z-index: 1100;
      display: none;
    }

    .hint {
      position: fixed;
      left: 8px;
      bottom: 60px;
      background: #ffffffec;
      padding: 8px 10px;
      border-radius: 10px;
      font-size: 12px;
      z-index: 1050;
      line-height: 1.4;
      max-width: 260px;
      white-space: normal;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12);
      display: none;
    }

    .auth-card {
      margin: 10px 12px 0;
      padding: 10px 12px;
      border: 1px solid #e5e7eb;
      border-radius: 10px;
      background: #fff;
    }

    footer {
      padding: 6px 10px;
      font-size: 12px;
      color: var(--muted);
      border-top: 1px solid #e5e7eb;
    }

    @media (max-width:600px) {
      header {
        flex-direction: column;
        align-items: flex-start;
      }

      .dock {
        flex-direction: column;
        right: 4px;
        bottom: 4px;
      }

      .toolbar {
        left: 4px;
        bottom: 4px;
      }
    }

    a.is-disabled {
      opacity: 0.45;
      pointer-events: none;
      cursor: not-allowed;
    }
  </style>
  <script
    src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/dist/umd/supabase.js?v=runfix"
    data-supabase-lib="1"
    defer
    onload="window.__supabaseLoaded = true; window.dispatchEvent(new Event('supabase-script-loaded'));"
    onerror="window.dispatchEvent(new Event('supabase-script-error'));"
  ></script>
</head>

<body>
  <div id="app">
    <header>
      <div style="font-weight:700;">Route MVP</div>
      <div class="tabs">
        <button id="tabLogs" class="tab active" type="button">ãƒ­ã‚°ä¸€è¦§</button>
        <button id="tabRun" class="tab" type="button">å®Ÿèµ°ã™ã‚‹</button>
      </div>
      <div style="display:flex; gap:6px; flex-wrap:wrap;">
        <a id="lnHome" class="btn ghost" href="index.html">å…¬é–‹ãƒ«ãƒ¼ãƒˆ</a>
        <a id="lnMyPage" class="btn ghost" href="mypage.html">ãƒã‚¤ãƒšãƒ¼ã‚¸</a>
      </div>
    </header>

    <div id="authBar" class="auth-card">èªè¨¼çŠ¶æ…‹ã‚’ç¢ºèªä¸­â€¦</div>

    <main>
      <section id="logsSection" class="panel active" aria-label="logs">
        <div id="logsList" class="list">èª­ã¿è¾¼ã¿ä¸­â€¦</div>
      </section>
      <section id="runSection" class="panel" aria-label="run">
        <div id="map"></div>
        <div class="badgewrap">
          <div id="courseBadge" class="badge" style="display:none;"></div>
        </div>
        <div class="dock">
          <button id="startBtn" class="btn primary big" type="button">â–¶ è¨˜éŒ²é–‹å§‹</button>
          <button id="stopBtn" class="btn danger big" type="button">â–  åœæ­¢</button>
          <button id="followBtn" class="btn ghost" type="button">ğŸ” è¿½å¾“ OFF</button>
          <button id="locateBtn" class="btn ghost" type="button">ğŸ“ ç¾åœ¨åœ°ã ã‘</button>
          <button id="backLogsBtn" class="btn ghost" type="button" style="display:none;">ğŸ“„ ãƒ­ã‚°ä¸€è¦§ã¸</button>
        </div>
        <div class="route-photo-upload">
          <label style="display:block; line-height:1.4;">
            ğŸ“· å†™çœŸã‚’è¿½åŠ <br><span class="muted">â–¶ã§èµ°è¡Œé–‹å§‹å¾Œã«ä½¿ç”¨å¯èƒ½</span>
            <input id="route-photo-input" type="file" accept="image/*" capture="environment" style="display:none;">
          </label>
          <div id="route-photo-upload-status" style="margin-top:4px;"></div>
          <div id="route-photo-list"></div>
        </div>
        <div class="toolbar" style="display:none;"><button id="editToggleBtn" class="btn ghost" type="button">âœï¸
            ç·¨é›†ãƒ¢ãƒ¼ãƒ‰</button></div>
        <div id="hint" class="hint">â–¶ã§GPS+è¨˜éŒ²+è¿½å¾“ON</div>
        <div id="toast" class="toast"></div>
      </section>
    </main>

    <div id="photoSummary" class="card"
      style="margin:12px 12px 0; display:flex; align-items:center; gap:10px; background:#fff; border:1px solid #e5e7eb; border-radius:12px; padding:10px 12px; box-shadow:0 6px 20px rgba(0,0,0,0.08);"
      hidden>
      <div>ğŸ“· æ’®ã£ãŸå†™çœŸ: <strong data-photo-count>0</strong>æš</div>
      <a id="lnPhotoList" class="btn ghost" role="button" style="text-decoration:none;">å†™çœŸä¸€è¦§ã‚’è¦‹ã‚‹</a>
    </div>

    <footer class="muted" style="margin-top:10px;">v: <code id="ver"></code></footer>
  </div>

  <script>
    document.getElementById('ver').textContent = window.APP_VERSION;
  </script>
<script src="js/app-common.js" defer></script>
<!-- <script src="js/run-photo-summary.js" defer></script> -->
<script src="js/auth-common.js" defer></script>
  <script defer>
    // èµ°è¡Œä¸­ã«ç´ã¥ã routes.idï¼ˆrun ãƒ­ã‚°ã¨ç´ã¥ã‘ã‚‹ãŸã‚ã®IDï¼‰
    let currentRouteId = null;
    let accountId = null;

    let supabaseClient = window.supabaseClient || null;
    let supabase = supabaseClient;
    let ensureAuth = supabase ? AppCommon.createEnsureAuth({
      supabase,
      getAccountId: window.AuthCommon?.getMyAccountId ? () => window.AuthCommon.getMyAccountId(supabase) : () => null
    }) : null;
    function syncSupabaseClient() {
      supabaseClient = window.supabaseClient || null;
      supabase = supabaseClient;
      ensureAuth = supabase ? AppCommon.createEnsureAuth({
        supabase,
        getAccountId: window.AuthCommon?.getMyAccountId ? () => window.AuthCommon.getMyAccountId(supabase) : () => null
      }) : null;
    }
    window.addEventListener('supabase-client-ready', syncSupabaseClient);
    syncSupabaseClient();

    const fileInput = document.getElementById('route-photo-input');
    const statusEl = document.getElementById('route-photo-upload-status');
    const listEl = document.getElementById('route-photo-list');
    const photoSummary = document.getElementById('photoSummary');
    const photoCountEl = photoSummary?.querySelector('[data-photo-count]');
    const photoListBtn = document.getElementById('lnPhotoList');
    const V = () => encodeURIComponent(window.APP_VERSION || '');
    function withTimeout(promise, ms, label = 'timeout') {
      return Promise.race([
        promise,
        new Promise((_, reject) =>
          setTimeout(() => reject(new Error(`${label} (${ms}ms)`)), ms)
        )
      ]);
    }

    function setLinkEnabled(a, enabled) {
      if (!a) return;
      a.setAttribute('aria-disabled', enabled ? 'false' : 'true');
      a.style.pointerEvents = enabled ? 'auto' : 'none';
      a.style.opacity = enabled ? '1' : '0.5';
    }

    if (photoListBtn && !photoListBtn.dataset.guardInstalled) {
      photoListBtn.dataset.guardInstalled = '1';
      photoListBtn.addEventListener('click', (e) => {
        if (photoListBtn.getAttribute('aria-disabled') === 'true') {
          e.preventDefault();
          e.stopPropagation();
        }
      });
    }

    function updatePhotoSummaryLink() {
      if (!photoSummary) return;

      const enabled = !!currentRouteId;
      if (!enabled) {
        photoSummary.hidden = true;
        setLinkEnabled(photoListBtn, false);
        return;
      }

      photoSummary.hidden = false;
      if (photoCountEl && !photoCountEl.textContent) photoCountEl.textContent = '0';

      const url = new URL('route-photos.html', window.location.origin);
      url.searchParams.set('route_id', String(currentRouteId));
      url.searchParams.set('v', V());

      if (photoListBtn) photoListBtn.href = url.toString();
      setLinkEnabled(photoListBtn, true);
    }

    // toast utility (page-wide)
    function showToast(msg) {
      const toastEl = document.getElementById('toast');
      if (!toastEl) return;
      toastEl.textContent = msg;
      toastEl.style.display = 'block';
      setTimeout(() => { toastEl.style.display = 'none'; }, 2000);
    }

    window.showToast = showToast;

    async function startNewRoute() {
      if (currentRouteId !== null) return { ok: true, routeId: currentRouteId };

      try {
        const ensured = await ensureAuth();
        accountId = ensured.accountId;
      } catch (authErr) {
        console.error('ensureAuth failed', authErr);
        alert(AppCommon.formatErrorMessage('ãƒ­ã‚°ã‚¤ãƒ³ãŒå¿…è¦ã§ã™', authErr));
        return { ok: false, error: authErr };
      }

      let payload;
      try {
        payload = AppCommon.buildRoutePayload({
          name: 'å®Ÿèµ°é–‹å§‹',
          isPublic: false,
          accountId,
          ownerAccountId: accountId,
          origin: 'from_log',
          routeType: 'from_run'
        });
      } catch (buildErr) {
        console.error('buildRoutePayload error', buildErr);
        showToast(AppCommon.formatErrorMessage('ãƒ«ãƒ¼ãƒˆé–‹å§‹ã®æº–å‚™ã«å¤±æ•—', buildErr));
        alert('ãƒ«ãƒ¼ãƒˆé–‹å§‹ã®æº–å‚™ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + (buildErr?.message || buildErr));
        return { ok: false, error: buildErr };
      }

      try {
        const { data, error, status } = await supabase
          .from('routes')
          .insert(payload)
          .select('id')
          .single();

        if (error) {
          console.error('routes insert error:', { status, error, payload });
          const msg = error?.message || 'ä¸æ˜ãªã‚¨ãƒ©ãƒ¼';
          const alertMsg = `ãƒ«ãƒ¼ãƒˆã®é–‹å§‹ã«å¤±æ•—ã—ã¾ã—ãŸã€‚\n(${msg})\né€ä¿¡ã‚­ãƒ¼:${Object.keys(payload).join(',')}\nv:${window.APP_VERSION}`;
          showToast(msg);
          alert(alertMsg);
          return { ok: false, error };
        }

        currentRouteId = data.id;
        showToast(`è¨˜éŒ²é–‹å§‹ #${currentRouteId}`);
        console.log('æ–°ã—ã„ route_id:', currentRouteId);
        loadRoutePhotos();
        updatePhotoSummaryLink();
        return { ok: true, routeId: currentRouteId };
      } catch (e) {
        console.error('routes insert exception', e);
        const msg = e?.message || e;
        showToast('ãƒ«ãƒ¼ãƒˆé–‹å§‹ã§ä¾‹å¤–: ' + msg);
        alert('ãƒ«ãƒ¼ãƒˆé–‹å§‹ã§ä¾‹å¤–ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ' + msg);
        return { ok: false, error: e };
      }
    }

    // route_spot_photos ã‚’èª­ã‚“ã§ã‚µãƒ ãƒã‚¤ãƒ«è¡¨ç¤º
    async function loadRoutePhotos() {
      if (!listEl) return;
      listEl.textContent = '';

      if (!currentRouteId) {
        listEl.textContent = '';
        if (photoSummary) photoSummary.hidden = true;
        return;
      }

      const { data, error, count } = await supabase
        .from('route_spot_photos')
        .select('id, image_url, taken_at', { count: 'exact' })
        .eq('route_id', currentRouteId)
        .order('taken_at', { ascending: true });

      if (error) {
        console.error('å†™çœŸä¸€è¦§å–å¾—ã‚¨ãƒ©ãƒ¼:', error);
        listEl.textContent = '';
        if (photoSummary) photoSummary.hidden = true;
        return;
      }

      if (!data || data.length === 0) {
        listEl.textContent = '';
        if (photoSummary) photoSummary.hidden = false;
        if (photoCountEl) photoCountEl.textContent = '0';
        updatePhotoSummaryLink();
        return;
      }

      listEl.innerHTML = data.map((photo) => `
        <div style="display:inline-block; margin:4px;">
          <img src="${photo.image_url}" style="width:80px; height:80px; object-fit:cover; border-radius:4px;" />
        </div>
      `).join('');
      if (photoSummary) photoSummary.hidden = false;
      if (photoCountEl) photoCountEl.textContent = String(typeof count === 'number' ? count : data.length);
      updatePhotoSummaryLink();
    }

    // åˆæœŸè¡¨ç¤ºæ™‚ã«èª­ã¿è¾¼ã‚€
    loadRoutePhotos();
    updatePhotoSummaryLink();

    if (fileInput && statusEl) {
      fileInput.addEventListener('change', async (event) => {
        const file = event.target.files?.[0];
        if (!file) return;

        if (!currentRouteId) {
          statusEl.textContent = 'ã¾ãšâ–¶ã§èµ°è¡Œã‚’é–‹å§‹ã—ã¦ãã ã•ã„ã€‚';
          fileInput.value = '';
          return;
        }

        statusEl.textContent = 'ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ä¸­â€¦';

        const timestamp = Date.now();
        const ext = file.name.split('.').pop() || 'jpg';
        const filePath = `${timestamp}.${ext}`;

        try {
          // â‘  Storage ã¸ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
          const { data, error } = await supabase.storage
            .from('route-photos')
            .upload(filePath, file, { upsert: false });

          if (error) {
            console.error('photo upload error', error);
            statusEl.textContent = 'ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å¤±æ•—';
            return;
          }

          // â‘¡ å…¬é–‹URLå–å¾—
          const {
            data: { publicUrl },
          } = supabase.storage.from('route-photos').getPublicUrl(data.path);
          console.log('ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰æˆåŠŸ URL:', publicUrl);

          // â‘¢ ãƒ­ã‚°ã‚¤ãƒ³ä¸­ãƒ¦ãƒ¼ã‚¶ãƒ¼å–å¾—
          // â‘¢ èªè¨¼ç¢ºèªï¼ˆã‚­ãƒ£ãƒƒã‚·ãƒ¥çµŒç”±ï¼‰
          let ensured;
          try {
            ensured = await ensureAuth();
          } catch (e) {
            console.error('ensureAuth (upload) error', e);
            statusEl.textContent = 'ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰æˆåŠŸï¼ˆDBç™»éŒ²ã¯å¤±æ•—ï¼šæœªãƒ­ã‚°ã‚¤ãƒ³ï¼‰';
            return;
          }
          const user = ensured?.user;
          const ensuredAccountId = ensured?.accountId || null;
          if (ensuredAccountId) accountId = ensuredAccountId;
          if (!user?.id) {
            statusEl.textContent = 'ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰æˆåŠŸï¼ˆDBç™»éŒ²ã¯å¤±æ•—ï¼šãƒ¦ãƒ¼ã‚¶ãƒ¼ä¸æ˜ï¼‰';
            return;
          }

          // â‘£ route_spot_photos ã«1è¡ŒINSERT
          const { error: insertError } = await supabase
            .from('route_spot_photos')
            .insert({
              route_id: currentRouteId,
              user_id: user.id,
              account_id: ensuredAccountId,
              image_url: publicUrl,
            });

          if (insertError) {
            console.error('route_spot_photos ã¸ã®INSERTã‚¨ãƒ©ãƒ¼:', insertError);
            statusEl.textContent = 'ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰æˆåŠŸï¼ˆDBç™»éŒ²ã¯å¤±æ•—ï¼‰';
            return;
          }

          statusEl.textContent = 'ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ & DBç™»éŒ² å®Œäº†ï¼';
          // è¿½åŠ ï¼šæœ€æ–°ä¸€è¦§ã‚’å†èª­ã¿è¾¼ã¿
          loadRoutePhotos();
          updatePhotoSummaryLink();
        } catch (err) {
          console.error('photo upload exception', err);
          statusEl.textContent = 'ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å¤±æ•—';
        } finally {
          fileInput.value = '';
        }
      });
    }
  </script>

<script src="js/storage.js" defer></script>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin="" defer></script>
<script src="https://cdn.jsdelivr.net/npm/@turf/turf@6.5.0/turf.min.js" defer></script>
<script defer>
  // Supabaseã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚’1å›ã ã‘ç”Ÿæˆï¼ˆãƒ©ã‚¤ãƒ–ãƒ©ãƒªwindow.supabaseã¯ä¿æŒï¼‰
  const SUPABASE_URL = 'https://cqiqhczxuiyakptdjowr.supabase.co';
  const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNxaXFoY3p4dWl5YWtwdGRqb3dyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTc3NzAwNzMsImV4cCI6MjA3MzM0NjA3M30.vCFQoQnsClINKa5tQAz-rNnF5XLEukmn_Nl0Err5k3k';
  const SUPABASE_SRC = 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/dist/umd/supabase.js?v=runfix';

  async function waitForSupabaseLibrary(timeoutMs = 5000) {
    const start = Date.now();
    while (Date.now() - start < timeoutMs) {
      if (window.supabase && typeof window.supabase.createClient === 'function') return true;
      if (window.__supabaseLoaded) return !!window.supabase;
      await new Promise((r) => setTimeout(r, 50));
    }
    return false;
  }

  async function ensureSupabaseClient(timeoutMs = 5000) {
    if (window.supabaseClient) {
      window.dispatchEvent(new Event('supabase-client-ready'));
      return true;
    }
    let libReady = await waitForSupabaseLibrary(timeoutMs);
    if (!libReady || !window.supabase?.createClient) {
      // ã‚­ãƒ£ãƒƒã‚·ãƒ¥/èª­ã¿è¾¼ã¿é †ã®å•é¡ŒãŒã‚ã‚‹å ´åˆã«å‚™ãˆã€æ”¹ã‚ã¦ script ã‚’å‹•çš„ãƒ­ãƒ¼ãƒ‰ï¼ˆcache bustï¼‰ã™ã‚‹
      try {
        await new Promise((resolve, reject) => {
          const s = document.createElement('script');
          s.src = `${SUPABASE_SRC}&bust=${Date.now()}`;
          s.defer = true;
          s.onload = () => resolve(true);
          s.onerror = reject;
          document.head.appendChild(s);
        });
      } catch (e) {
        console.warn('supabase lib reload failed', e);
      }
      libReady = await waitForSupabaseLibrary(3000);
      if (!libReady || !window.supabase?.createClient) return false;
    }

    try {
      window.supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
        auth: { persistSession: true, autoRefreshToken: true, detectSessionInUrl: false }
      });
    } catch (e) {
      console.error('supabase client init failed', e);
      return false;
    }

    // AuthCommon ãŒã¾ã èª­ã¿è¾¼ã¾ã‚Œã¦ã„ãªã„å ´åˆã§ã‚‚ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆç”Ÿæˆã¯æˆåŠŸã•ã›ã‚‹
    try {
      if (window.AuthCommon?.init) {
        window.AuthCommon.init(window.supabaseClient, { redirectUrl: 'index.html' });
      } else {
        console.warn('AuthCommon not ready yet');
      }
      if (window.AuthCommon?.getMyAccountId) {
        window.getMyAccountId = () => window.AuthCommon.getMyAccountId(window.supabaseClient);
      } else {
        window.getMyAccountId = () => null;
      }
    } catch (e) {
      console.warn('AuthCommon init failed (continue without blocking)', e);
      window.getMyAccountId = () => null;
    }

    window.dispatchEvent(new Event('supabase-client-ready'));
    return true;
  }

  document.addEventListener('DOMContentLoaded', async () => {
    const authBar = document.getElementById('authBar');

    const ok = await ensureSupabaseClient(5000);
    if (!ok) {
      if (authBar) authBar.textContent = 'ERROR: supabaseClient ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“';
      return;
    }
  });
</script>
<script defer>
  // Supabase åˆæœŸåŒ–ã€‚ä»¥å‰ã¯ client ã‚’ window.supabase ã«ä¸Šæ›¸ãã—ã¦ã„ãŸãŸã‚ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒå‚ç…§ã§ããšæ­¢ã¾ã£ã¦ã„ãŸã€‚
  let __runBooted = false;

  async function startApp(trigger = 'dcl') {
      if (__runBooted) return;
      // â˜…èµ·å‹•ãƒãƒ¼ã‚«ãƒ¼ï¼šã“ã‚ŒãŒç”»é¢ã«å‡ºãªã„ãªã‚‰ã€DOMContentLoadedã¾ã§åˆ°é”ã—ã¦ã„ãªã„
      const authBar = document.getElementById('authBar');
      if (authBar) authBar.textContent = 'JSèµ·å‹•â€¦ï¼ˆDOMContentLoadedåˆ°é”ï¼‰';
      console.log('[run] startApp', trigger, new Date().toISOString());
      // â˜…ã‚¦ã‚©ãƒƒãƒãƒ‰ãƒƒã‚°ï¼šä½•ãŒèµ·ãã¦ã‚‚3.5ç§’å¾Œã«ã€Œç¢ºèªä¸­ã€ã‹ã‚‰å¤‰ãˆã‚‹
      setTimeout(() => {
        const el = document.getElementById('authBar');
        if (!el) return;
        if (el.textContent && el.textContent.includes('èªè¨¼çŠ¶æ…‹ã‚’ç¢ºèªä¸­')) {
          el.textContent = 'èªè¨¼ç¢ºèªãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸï¼ˆJSã¯å‹•ã„ã¦ã„ã¾ã™ï¼‰ã€‚ã‚­ãƒ£ãƒƒã‚·ãƒ¥/é€šä¿¡/èªè¨¼ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚';
        }
      }, 3500);

      const supabaseReady = await ensureSupabaseClient(5000);
      if (!supabaseReady) {
        if (authBar) authBar.textContent = 'ERROR: supabaseClient ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“';
        return;
      }

      if (!supabaseClient) {
        supabaseClient = window.supabaseClient; // ensureSupabaseClient ã§ç”Ÿæˆæ¸ˆã¿
      }

      supabase = supabaseClient;
      const getAccountId = window.AuthCommon?.getMyAccountId ? () => window.AuthCommon.getMyAccountId(supabase) : () => null;
      ensureAuth = AppCommon.createEnsureAuth({ supabase, getAccountId });
      if (window.AuthCommon?.init) {
        try {
          window.AuthCommon.init(supabase, { redirectUrl: 'index.html' });
        } catch (e) {
          console.warn('AuthCommon init (startApp) failed', e);
        }
      } else {
        console.warn('AuthCommon not ready yet (startApp)');
      }
      if (!supabase) {
        if (authBar) authBar.textContent = 'ERROR: supabase ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“';
        return;
      }
      __runBooted = true;

      const tabLogs = document.getElementById('tabLogs');
      const tabRun = document.getElementById('tabRun');
      const logsSection = document.getElementById('logsSection');
      const runSection = document.getElementById('runSection');
      const logsList = document.getElementById('logsList');
      const startBtn = document.getElementById('startBtn');
      const stopBtn = document.getElementById('stopBtn');
      const followBtn = document.getElementById('followBtn');
      const locateBtn = document.getElementById('locateBtn');
      const backLogsBtn = document.getElementById('backLogsBtn');
      const editToggleBtn = document.getElementById('editToggleBtn');
      const toastEl = document.getElementById('toast');
      const hintEl = document.getElementById('hint');
      const badgeEl = document.getElementById('courseBadge');
      const lnHome = document.getElementById('lnHome');
      const lnMyPage = document.getElementById('lnMyPage');
      if (lnHome) lnHome.href = `index.html?v=${V()}`;
      if (lnMyPage) lnMyPage.href = `mypage.html?v=${V()}`;
      if (startBtn) startBtn.disabled = true; // èªè¨¼çŠ¶æ…‹ãŒåˆ¤æ˜ã™ã‚‹ã¾ã§ä¸€æ—¦ç„¡åŠ¹ã€renderAuthBarã§åˆ¶å¾¡
      if (stopBtn) stopBtn.disabled = true;

      let map;
      let routePts = [];
      let routeLine;
      let editMode = false;
      let recording = false;
      let follow = false;
      let dot = null;
      let accCircle = null;
      let lastLatLng = null;
      let traced = [];
      let tracedLine = null;
      let lastAddTs = 0;
      let lastSavedLogId = null;
      let rawTrack = [];
      let wakeLock = null;

      // è¿½å¾“ãƒ«ãƒ¼ãƒˆï¼†ãƒ©ã‚¤ãƒ³ãƒ¬ã‚¤ãƒ¤
      let planned = [];        // äºˆå®šãƒ«ãƒ¼ãƒˆï¼ˆ{lat,lng}[]ï¼‰
      let plannedLayer = null; // äºˆå®šãƒ©ã‚¤ãƒ³ï¼ˆé’ï¼‰
      let layerOn = null;      // å®Ÿèµ°ã‚ªãƒ³ãƒ«ãƒ¼ãƒˆï¼ˆç·‘ï¼‰
      let layerOff = null;     // å®Ÿèµ°é€¸è„±ï¼ˆèµ¤ï¼‰

      const ACC_LIMIT = 100;
      const MIN_MOVE = 3;
      const MIN_INTERVAL_MS = 1000;
      const GEO_OPTIONS = { enableHighAccuracy: true, maximumAge: 0, timeout: 20000 };
      const COLORS = {
        planned: '#3b82f6',
        liveOn: '#10b981',
        liveOff: '#ef4444'
      };
      const OFF_THRESHOLD_M = 30;

      const decodePolyline = (str) => {
        try {
          let idx = 0, lat = 0, lng = 0;
          const out = [];
          while (idx < str.length) {
            let b, shift = 0, result = 0;
            do {
              b = str.charCodeAt(idx++) - 63;
              result |= (b & 0x1f) << shift;
              shift += 5;
            } while (b >= 0x20);
            const dlat = (result & 1) ? ~(result >> 1) : (result >> 1);
            shift = 0;
            result = 0;
            do {
              b = str.charCodeAt(idx++) - 63;
              result |= (b & 0x1f) << shift;
              shift += 5;
            } while (b >= 0x20);
            const dlng = (result & 1) ? ~(result >> 1) : (result >> 1);
            lat += dlat;
            lng += dlng;
            out.push({ lat: lat / 1e5, lng: lng / 1e5 });
          }
          return out;
        } catch (e) {
          console.warn('decodePolyline error', e);
          return [];
        }
      };

      const escapeHtml = (str) => (str ?? '').replace(/[&<>"']/g, (c) => ({
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;'
      })[c] || c);
      const fmtDateTime = (v) => v ? new Date(v).toLocaleString() : '-';
      const fmtDistance = (m) => (m ? `${(m / 1000).toFixed(2)} km` : '-');
      const fmtDuration = (sec) => {
        if (!sec && sec !== 0) return '-';
        const h = Math.floor(sec / 3600);
        const m = Math.floor((sec % 3600) / 60);
        const s = sec % 60;
        return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
      };
      const showToast = (msg) => {
        toastEl.textContent = msg;
        toastEl.style.display = 'block';
        setTimeout(() => { toastEl.style.display = 'none'; }, 2000);
      };
      const setBadge = (state, text) => {
        const el = badgeEl;
        if (!el) return;
        el.className = `badge ${state || ''}`.trim();
        el.textContent = text || '';
        el.style.display = text ? 'inline-flex' : 'none';
      };
      setBadge('', ''); // åˆæœŸã¯éè¡¨ç¤ºã«ã™ã‚‹

      function setTab(tab) {
        const showRun = tab === 'run';
        tabLogs.classList.toggle('active', !showRun);
        tabRun.classList.toggle('active', showRun);
        logsSection.classList.toggle('active', !showRun);
        runSection.classList.toggle('active', showRun);
        logsSection.style.display = showRun ? 'none' : 'flex';
        runSection.style.display = showRun ? 'block' : 'none';
        if (showRun) {
          initMapOnce();
          loadPlannedRouteIfAny();
          clearLiveLayers();
          setTimeout(() => { map && map.invalidateSize(true); }, 120);
        } else {
          clearWatchIfAny();
          recording = false;
          setBadge('', 'è¨˜éŒ²åœæ­¢');
        }
      }

      async function renderAuthBar() {
        const loginUrl = `login.html?v=${V()}`;
        const myPageUrl = `mypage.html?v=${V()}`;
        try {
          // â‘  Supabase Authã§ãƒ¦ãƒ¼ã‚¶ãƒ¼ã ã‘å…ˆã«ç¢ºå®š
          const { data, error } = await withTimeout(supabase.auth.getUser(), 1500, 'getUser timeout');
          if (error) throw error;
          if (!data?.user) throw new Error('NOT_AUTHENTICATED');

          const email = data.user.email || '';

          // â‘¡ accountId ã¯å–å¾—ã§ããŸã‚‰ä½¿ã†ï¼ˆå¤±æ•—ã—ã¦ã‚‚UIã¯å‰ã«é€²ã‚ã‚‹ï¼‰
          try {
            const ensured = await withTimeout(ensureAuth(), 2000, 'ensureAuth timeout');
            accountId = ensured.accountId;
          } catch (e) {
            console.warn('accountId not ready (ensureAuth failed)', e);
            accountId = null;
          }

          authBar.innerHTML = `
        ãƒ­ã‚°ã‚¤ãƒ³ä¸­: <strong>${escapeHtml(email)}</strong>
        <div style="margin-top:6px; display:flex; gap:6px; flex-wrap:wrap;">
          <a class="btn ghost" href="${myPageUrl}">ãƒã‚¤ãƒšãƒ¼ã‚¸ã¸</a>
          <button class="btn ghost" data-signout type="button">ã‚µã‚¤ãƒ³ã‚¢ã‚¦ãƒˆ</button>
        </div>
        ${accountId ? '' : '<div class="meta" style="margin-top:6px;">â€»ã‚¢ã‚«ã‚¦ãƒ³ãƒˆæƒ…å ±ã®å–å¾—ãŒé…ã‚Œã¦ã„ã¾ã™ï¼ˆãƒ­ã‚°è¡¨ç¤º/ä¿å­˜ãŒåˆ¶é™ã•ã‚Œã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ï¼‰</div>'}
      `;
          const isRecording = !!recording;
          if (startBtn) startBtn.disabled = isRecording || !accountId;
          if (stopBtn) stopBtn.disabled = !isRecording || !accountId;
        } catch (e) {
          console.error('renderAuthBar error', e);
          authBar.innerHTML = `
        æœªãƒ­ã‚°ã‚¤ãƒ³ã§ã™ã€‚ãƒ­ã‚°ã‚’ä¿å­˜ã™ã‚‹ã«ã¯ <a class="btn ghost" href="${loginUrl}">ãƒ­ã‚°ã‚¤ãƒ³</a> ã—ã¦ãã ã•ã„ã€‚
      `;
          accountId = null;
          if (startBtn) startBtn.disabled = true;
          if (stopBtn) stopBtn.disabled = true;
        }
      }

      // å¿µã®ãŸã‚ã€åˆå›æç”»ãŒå‹•ã‹ãªã‹ã£ãŸå ´åˆã«å†è©¦è¡Œã™ã‚‹ä¿é™º
      setTimeout(() => {
        try {
          if (authBar?.textContent?.includes('èªè¨¼çŠ¶æ…‹ã‚’ç¢ºèªä¸­')) {
            renderAuthBar();
          }
        } catch (e) {
          console.warn('authBar retry failed', e);
        }
      }, 2000);

      async function renderLogs() {
        logsList.textContent = 'èª­ã¿è¾¼ã¿ä¸­â€¦';
        try {
          if (!accountId) {
            await renderAuthBar();
            if (!accountId) {
              logsList.innerHTML = '<div class="meta">æœªãƒ­ã‚°ã‚¤ãƒ³ã§ã™ã€‚ä¿å­˜ã—ãŸãƒ­ã‚°ã‚’è¡¨ç¤ºã™ã‚‹ã«ã¯ãƒ­ã‚°ã‚¤ãƒ³ã—ã¦ãã ã•ã„ã€‚</div>';
              return;
            }
          }

          const { data: runs, error } = await supabase
            .from('runs')
            .select('id, name, created_at, started_at, ended_at, distance_m, duration_s')
            .eq('account_id', accountId)
            .order('created_at', { ascending: false });

          if (error) throw error;
          if (!runs || runs.length === 0) {
            logsList.innerHTML = '<div class="meta">ä¿å­˜ã•ã‚ŒãŸå®Ÿèµ°ãƒ­ã‚°ã¯ã¾ã ã‚ã‚Šã¾ã›ã‚“ã€‚è¨˜éŒ²é–‹å§‹ãƒœã‚¿ãƒ³ã‹ã‚‰å®Ÿèµ°ã‚’è¨˜éŒ²ã—ã¦ãã ã•ã„ã€‚</div>';
            return;
          }

          logsList.innerHTML = '';
          for (const r of runs) {
            const when = r.ended_at
              ? new Date(r.ended_at).toLocaleString()
              : (r.started_at
                ? new Date(r.started_at).toLocaleString()
                : (r.created_at ? new Date(r.created_at).toLocaleString() : '-'));
            const title = r.name || when;
            const km = (r.distance_m != null) ? `${(Number(r.distance_m) / 1000).toFixed(2)} km` : '-';
            const durMin = (r.duration_s != null) ? Math.round(Number(r.duration_s) / 60) + ' åˆ†' : '-';
            const card = document.createElement('div');
            card.className = 'card';
            card.innerHTML = `
              <div style="flex:1 1 auto;">
                <div style="font-weight:600;">${escapeHtml(title)} <span class="meta">#${r.id}</span></div>
                <div class="meta">${when}</div>
                <div class="meta">${km} / ${durMin}</div>
              </div>
              <div style="display:flex; gap:6px; flex-wrap:wrap;">
                <a class="btn ghost" href="detail.html?id=${encodeURIComponent(r.id)}&kind=run&v=${V()}">è©³ç´°</a>
              </div>
            `;
            logsList.appendChild(card);
          }
        } catch (e) {
          console.error('renderLogs error', e);
          logsList.textContent = 'ãƒ­ã‚°ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ';
        }
      }

      let _watchId = null;

      const clearWatchIfAny = () => {
        if (_watchId != null) {
          navigator.geolocation.clearWatch(_watchId);
          _watchId = null;
        }
      };

      function initMapOnce() {
        if (map) return;
        if (!window.L || !window.turf) {
          console.warn('map libs not ready yet; retrying...');
          setTimeout(initMapOnce, 300);
          return;
        }
        map = L.map('map').setView([35.681236, 139.767125], 14);
        L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
          maxZoom: 19,
          attribution: '&copy; OpenStreetMap contributors'
        }).addTo(map);
        routeLine = L.polyline(routePts, { color: '#2563eb', weight: 4 }).addTo(map);
        ensureLiveLayers();
        setBadge('', '');
        map.on('click', (e) => {
          if (!editMode || recording) return;
          routePts.push([e.latlng.lat, e.latlng.lng]);
          routeLine.setLatLngs(routePts);
          if (routePts.length > 1) {
            map.fitBounds(routeLine.getBounds(), { padding: [24, 24] });
          }
          if (lastLatLng) updateCourseStatus(lastLatLng);
        });
        loadPlannedRouteIfAny();
      }

      let plannedRouteLoaded = false;
      const initialRouteId = (() => {
        const val = new URL(location.href).searchParams.get('route');
        if (val == null) return null;
        const num = Number(val);
        return Number.isFinite(num) ? num : null;
      })();

      async function loadPlannedRouteIfAny(force = false) {
        if (!map) return;
        try {
          const rid = initialRouteId;
          if (!rid) {
            planned = [];
            if (plannedLayer) {
              plannedLayer.remove();
              plannedLayer = null;
            }
            plannedRouteLoaded = false;
            setBadge('', '');
            return;
          }
          if (plannedRouteLoaded && !force) return;
          const { data: route, error } = await supabase
            .from('routes')
            .select('*')
            .eq('id', rid)
            .maybeSingle();
          if (error || !route) return;

          const pts = extractLatLngsFromRoute(route);
          if (!pts.length) return;
          planned = pts;
          plannedRouteLoaded = true;

          if (plannedLayer) {
            plannedLayer.remove();
            plannedLayer = null;
          }
          plannedLayer = L.polyline(planned.map(p => [p.lat, p.lng]), { color: COLORS.planned, weight: 5 }).addTo(map);
          plannedLayer.bringToBack();
          ensureLiveLayers();
          layerOn.bringToFront();
          layerOff.bringToFront();
          map.fitBounds(plannedLayer.getBounds(), { padding: [24, 24], maxZoom: 16 });
          setBadge('', '');
        } catch (e) {
          console.warn('loadPlannedRouteIfAny', e);
        }
      }

      function extractLatLngsFromRoute(route) {
        try {
          if (route.geojson) {
            const g = typeof route.geojson === 'string' ? JSON.parse(route.geojson) : route.geojson;
            const out = [];
            const walk = (geom) => {
              if (!geom) return;
              const t = geom.type;
              const co = geom.coordinates;
              if (t === 'LineString') co.forEach(([lng, lat]) => out.push({ lat, lng }));
              else if (t === 'MultiLineString') co.forEach(line => line.forEach(([lng, lat]) => out.push({ lat, lng })));
              else if (t === 'GeometryCollection') (geom.geometries || []).forEach(walk);
            };
            if (g.type === 'Feature') walk(g.geometry);
            else if (g.type === 'FeatureCollection') (g.features || []).forEach(f => walk(f.geometry));
            else walk(g);
            if (out.length) return out;
          }
        } catch (e) {
          console.warn('extractLatLngsFromRoute geojson', e);
        }
        if (route.polyline) {
          return decodePolyline(route.polyline);
        }
        return [];
      }

      function currentFollowLineLatLngs() {
        if (planned && planned.length >= 2) return planned.map(p => [p.lat, p.lng]);
        return (routePts && routePts.length >= 2) ? routePts.map(([la, ln]) => [la, ln]) : [];
      }

      function ensureLiveLayers() {
        if (!map) return;
        if (!layerOn) layerOn = L.polyline([], { color: COLORS.liveOn, weight: 5 }).addTo(map);
        if (!layerOff) layerOff = L.polyline([], { color: COLORS.liveOff, weight: 5 }).addTo(map);
      }

      function clearLiveLayers() {
        if (!map) return;
        ensureLiveLayers();
        if (layerOn) {
          layerOn.setLatLngs([]);
          layerOn.bringToFront();
        }
        if (layerOff) {
          layerOff.setLatLngs([]);
          layerOff.bringToFront();
        }
      }

      const cleanupRun = () => {
        try { clearWatchIfAny(); } catch (_) { }
        try { clearLiveLayers(); } catch (_) { }
        try { releaseWakeLock(); } catch (_) { }
        recording = false;
        traced = [];
        lastAddTs = 0;
        plannedRouteLoaded = false;
        rawTrack = [];
      };

      const m2deg = (m) => m / 111320;
      const encodePolyline = (latlngs) => {
        try {
          const pts = latlngs.map((p) => Array.isArray(p) ? { lat: p[0], lng: p[1] } : p);
          let lastLat = 0;
          let lastLng = 0;
          let enc = '';
          const e5 = (n) => Math.round(n * 1e5);
          const push = (v) => {
            v = v < 0 ? ~(v << 1) : (v << 1);
            while (v >= 0x20) {
              enc += String.fromCharCode((0x20 | (v & 0x1f)) + 63);
              v >>= 5;
            }
            enc += String.fromCharCode(v + 63);
          };
          for (const p of pts) {
            const la = e5(p.lat);
            const ln = e5(p.lng);
            push(la - lastLat);
            push(ln - lastLng);
            lastLat = la;
            lastLng = ln;
          }
          return enc;
        } catch (e) {
          console.error('encodePolyline error', e);
          return '';
        }
      };
      const movingAverage = (latlngs) => {
        if (latlngs.length < 3) return latlngs.slice();
        const out = latlngs.map((p) => p.slice());
        for (let i = 1; i < latlngs.length - 1; i++) {
          out[i][0] = (latlngs[i - 1][0] + latlngs[i][0] + latlngs[i + 1][0]) / 3;
          out[i][1] = (latlngs[i - 1][1] + latlngs[i][1] + latlngs[i + 1][1]) / 3;
        }
        return out;
      };
      const dedupeTinyMoves = (latlngs) => {
        if (latlngs.length < 2) return latlngs.slice();
        const out = [latlngs[0]];
        for (let i = 1; i < latlngs.length; i++) {
          const a = L.latLng(out[out.length - 1][0], out[out.length - 1][1]);
          const b = L.latLng(latlngs[i][0], latlngs[i][1]);
          if (a.distanceTo(b) >= 2) out.push(latlngs[i]);
        }
        return out;
      };
      const resampleByDistance = (latlngs, stepMeters) => {
        if (latlngs.length < 2) return latlngs.slice();
        const ls = turf.lineString(latlngs.map(([la, ln]) => [ln, la]));
        const lenKm = turf.length(ls, { units: 'kilometers' });
        const stepKm = stepMeters / 1000;
        const pts = [];
        for (let d = 0; d <= lenKm; d += stepKm) {
          const p = turf.along(ls, d, { units: 'kilometers' });
          const [lng, lat] = p.geometry.coordinates;
          pts.push([lat, lng]);
        }
        return pts.length ? pts : latlngs.slice();
      };

      const canUseWakeLock = () => {
        return typeof navigator !== 'undefined' && !!navigator.wakeLock?.request;
      };
      const requestWakeLock = async () => {
        if (!canUseWakeLock() || wakeLock) return;
        try {
          wakeLock = await navigator.wakeLock.request('screen');
          wakeLock?.addEventListener?.('release', () => {
            wakeLock = null;
          });
        } catch (err) {
          console.warn('wakeLock request failed', err);
          wakeLock = null;
        }
      };
      const releaseWakeLock = async () => {
        if (!wakeLock) return;
        try {
          await wakeLock.release();
        } catch (err) {
          console.warn('wakeLock release failed', err);
        } finally {
          wakeLock = null;
        }
      };

      const updateCourseStatus = (latlng) => {
        if (!window.turf) {
          setBadge('', 'ãƒ«ãƒ¼ãƒˆåˆ¤å®šå¾…ã¡ï¼ˆãƒ©ã‚¤ãƒ–ãƒ©ãƒªèª­è¾¼ä¸­ï¼‰');
          return;
        }
        const ref = currentFollowLineLatLngs();
        if (!ref.length) {
          setBadge('', 'ãƒ«ãƒ¼ãƒˆæœªè¨­å®š');
          return;
        }
        try {
          const point = turf.point([latlng.lng, latlng.lat]);
          const line = turf.lineString(ref.map(([la, ln]) => [ln, la]));
          const d = turf.pointToLineDistance(point, line, { units: 'meters' });
          if (d <= OFF_THRESHOLD_M) setBadge('ok', `ON COURSEï¼ˆ~${Math.round(d)}mï¼‰`);
          else if (d <= OFF_THRESHOLD_M * 2) setBadge('warn', `æ³¨æ„ï¼š${Math.round(d)}må¤–`);
          else setBadge('off', `ãƒ«ãƒ¼ãƒˆå¤–ï¼š${Math.round(d)}m`);
        } catch (e) {
          console.error('updateCourseStatus error', e);
          setBadge('', 'ãƒ«ãƒ¼ãƒˆåˆ¤å®šã‚¨ãƒ©ãƒ¼');
        }
      };

      const resetRunLayers = () => {
        if (!map) return;
        if (tracedLine) {
          map.removeLayer(tracedLine);
          tracedLine = null;
        }
        traced = [];
        lastAddTs = 0;
        recording = false;
        setEditMode(false);
        clearLiveLayers();
        const hasReference = currentFollowLineLatLngs().length >= 2;
        setBadge('', hasReference ? 'äºˆå®šãƒ«ãƒ¼ãƒˆèª­è¾¼æ¸ˆã¿ï¼ˆé’ï¼‰ï¼â–¶ã§è¨˜éŒ²é–‹å§‹' : 'âœï¸ã§ãƒ«ãƒ¼ãƒˆç·¨é›†ã€â–¶ã§è¨˜éŒ²é–‹å§‹');
      };

      const setEditMode = (on) => {
        editMode = !!on;
        if (editToggleBtn) {
          editToggleBtn.textContent = editMode ? 'âœ… ç·¨é›†çµ‚äº†ï¼ˆãƒ­ãƒƒã‚¯ï¼‰' : 'âœï¸ ç·¨é›†ãƒ¢ãƒ¼ãƒ‰';
        }
        if (hintEl) {
          hintEl.textContent = editMode
            ? 'ãƒ«ãƒ¼ãƒˆã«æ²¿ã£ã¦åœ°å›³ã‚’ã‚¿ãƒƒãƒ—ã—ã¦ãƒã‚¤ãƒ³ãƒˆã‚’è¿½åŠ ã§ãã¾ã™ã€‚'
            : 'â–¶ã§GPS+è¨˜éŒ²+è¿½å¾“ONã€‚â– åœæ­¢ã§ä¿å­˜ç¢ºèªâ†’ä¿å­˜å¾Œã¯ãƒ­ã‚°ä¸€è¦§ã¸ã€‚';
        }
      };

      const onPos = (pos) => {
        const { latitude: lat, longitude: lng, accuracy: acc } = pos.coords;
        const latlng = L.latLng(lat, lng);
        lastLatLng = latlng;
        ensureLiveLayers();
        if (!dot) {
          dot = L.circleMarker(latlng, { radius: 6, weight: 2, color: '#2563eb', fillColor: '#3b82f6', fillOpacity: 1 }).addTo(map);
          accCircle = L.circle(latlng, { radius: acc, color: '#93c5fd', weight: 1, fillColor: '#bfdbfe', fillOpacity: 0.25 }).addTo(map);
        } else {
          dot.setLatLng(latlng);
          accCircle.setLatLng(latlng).setRadius(acc);
        }
        if (follow) map.panTo(latlng, { animate: true });

        const now = Date.now();
        if (recording && acc <= ACC_LIMIT && (now - lastAddTs) >= MIN_INTERVAL_MS) {
          const prev = traced[traced.length - 1];
          const moved = !prev || latlng.distanceTo(L.latLng(prev[0], prev[1])) >= MIN_MOVE;
          if (moved) {
            traced.push([lat, lng]);
            rawTrack.push({ lat, lng, acc, ts: now });
            lastAddTs = now;
            appendLivePoint(lat, lng);
          }
        }
        updateCourseStatus(latlng);
      };

      function appendLivePoint(lat, lng) {
        ensureLiveLayers();
        let isOn = true;
        const ref = currentFollowLineLatLngs();
        if (ref.length >= 2 && window.turf) {
          try {
            const point = turf.point([lng, lat]);
            const line = turf.lineString(ref.map(([la, ln]) => [ln, la]));
            const d = turf.pointToLineDistance(point, line, { units: 'meters' });
            isOn = d <= OFF_THRESHOLD_M;
          } catch (e) {
            console.warn('appendLivePoint distance error', e);
          }
        }
        if (isOn) layerOn.addLatLng([lat, lng]);
        else layerOff.addLatLng([lat, lng]);
        layerOn.bringToFront();
        layerOff.bringToFront();
      }

      function ensureLineMin2(pts) {
        if (!Array.isArray(pts) || !pts.length) return [];
        if (pts.length >= 2) return pts;
        const p = pts[0];
        return [p, { lat: p.lat, lng: p.lng, ts: (p.ts || Date.now()) + 1, acc: p.acc || 0 }];
      }

      const onErr = (err) => {
        console.warn('geolocation error', err);
        showToast('ä½ç½®æƒ…å ±ã‚’å–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸ');
        clearWatchIfAny();
        recording = false;
        showRecUI && showRecUI(false);
        setBadge('off', 'ä½ç½®æƒ…å ±ã‚¨ãƒ©ãƒ¼');
        if (stopBtn) stopBtn.disabled = true;
        if (startBtn) startBtn.disabled = false;
        releaseWakeLock();
      };

      startBtn.addEventListener('click', async () => {
        if (!('geolocation' in navigator)) {
          alert('ã“ã®ç«¯æœ«ã§ã¯ä½ç½®æƒ…å ±ãŒä½¿ãˆã¾ã›ã‚“');
          return;
        }
        if (recording) {
          showToast('ã™ã§ã«è¨˜éŒ²ä¸­ã§ã™');
          return;
        }
        showToast('é–‹å§‹ãƒœã‚¿ãƒ³ã‚’å—ã‘ä»˜ã‘ã¾ã—ãŸ');

        let routeResult = { ok: false, error: null };
        try {
          if (startBtn) startBtn.disabled = true;
          routeResult = await startNewRoute();
        } catch (e) {
          console.error('startNewRoute exception', e);
          showToast('ãƒ«ãƒ¼ãƒˆé–‹å§‹ã«å¤±æ•—ã—ã¾ã—ãŸ');
          routeResult = { ok: false, error: e };
        }

        if (!routeResult?.ok || !routeResult.routeId) {
          const msg = routeResult?.error?.message || routeResult?.error || 'ãƒ«ãƒ¼ãƒˆé–‹å§‹ã«å¤±æ•—ã—ã¾ã—ãŸ';
          showToast(String(msg));
          if (startBtn && !recording) startBtn.disabled = false;
          return;
        }

        setBadge('', 'ç¾åœ¨åœ°ã‚’å–å¾—ä¸­â€¦');
        showToast(`ãƒ«ãƒ¼ãƒˆä½œæˆOK (#${routeResult.routeId}) / ä½ç½®å–å¾—ã‚’é–‹å§‹ã—ã¾ã™`);
        let started = false;

        const geoSuccess = (pos) => {
          started = true;
          try {
            onPos(pos);
          } catch (e) {
            console.warn('geolocation first fix onPos failed', e);
          }
          follow = true;
          followBtn.textContent = 'ğŸ” è¿½å¾“ ON';
          clearWatchIfAny();
          _watchId = navigator.geolocation.watchPosition(onPos, onErr, GEO_OPTIONS);

          setEditMode(false);
          recording = true;
          traced = [];
          lastAddTs = 0;
          rawTrack = [];
          if (tracedLine) {
            map.removeLayer(tracedLine);
            tracedLine = null;
          }
          clearLiveLayers();
          window.__logStartedAt = new Date().toISOString();
          setBadge('warn', 'è¨˜éŒ²ä¸­ï¼šã‚ªãƒ³ã‚³ãƒ¼ã‚¹åˆ¤å®šæœ‰åŠ¹');
          showToast('è¨˜éŒ²ã‚’é–‹å§‹ã—ã¾ã—ãŸ');
          if (stopBtn) stopBtn.disabled = false;
          if (startBtn) startBtn.disabled = true;
          requestWakeLock();
        };

        const geoError = (err) => {
          console.warn('geolocation first fix error', err);
          clearWatchIfAny();
          recording = false;
          const detail = err?.message ? `\n(${err.message})` : '';
          alert(`ä½ç½®æƒ…å ±ãŒç‰¹å®šã§ãã¾ã›ã‚“ã€‚ä½ç½®æƒ…å ±ã®åˆ©ç”¨ã‚’è¨±å¯ã—ã¦ã„ã‚‹ã‹ç¢ºèªã—ã¦ãã ã•ã„ã€‚${detail}`);
          setBadge('off', 'ä½ç½®å–å¾—å¤±æ•—');
          if (startBtn) startBtn.disabled = false;
          if (stopBtn) stopBtn.disabled = true;
        };

        navigator.geolocation.getCurrentPosition(geoSuccess, geoError, GEO_OPTIONS);

        setTimeout(() => {
          if (recording || started) return;
          if (startBtn) startBtn.disabled = false;
          showToast('ä½ç½®å–å¾—ãŒé–‹å§‹ã§ãã¾ã›ã‚“ã§ã—ãŸï¼ˆè¨±å¯ã‚„é€šä¿¡çŠ¶æ…‹ã‚’ç¢ºèªã—ã¦ãã ã•ã„ï¼‰');
        }, 8000);
      });


      stopBtn.addEventListener('click', async () => {
        if (!recording) { showToast('è¨˜éŒ²ã¯é–‹å§‹ã•ã‚Œã¦ã„ã¾ã›ã‚“'); return; }

        if (!accountId) {
          try {
            const ensured = await ensureAuth();
            accountId = ensured.accountId;
          } catch (e) {
            alert('ã‚¢ã‚«ã‚¦ãƒ³ãƒˆæƒ…å ±ã‚’ç¢ºèªã§ããªã„ãŸã‚ã€ä¿å­˜ã§ãã¾ã›ã‚“ã€‚ãƒ­ã‚°ã‚¤ãƒ³ã—ã¦ãã ã•ã„ã€‚');
            return;
          }
        }

        recording = false;
        clearWatchIfAny();
        releaseWakeLock();
        if (stopBtn) stopBtn.disabled = true;
        if (startBtn) startBtn.disabled = false;

        const count = traced.length;
        const ok = confirm(`è¨˜éŒ²ã‚’åœæ­¢ã—ã¾ã™ã€‚ãƒ­ã‚°ã‚’ä¿å­˜ã—ã¾ã™ã‹ï¼Ÿï¼ˆãƒã‚¤ãƒ³ãƒˆæ•°: ${count}ï¼‰`);
        if (!ok) { setBadge('', 'è¨˜éŒ²åœæ­¢'); showToast('ä¿å­˜ã›ãšçµ‚äº†'); window.__logStartedAt = null; return; }

        const raw = (Array.isArray(rawTrack) && rawTrack.length)
          ? rawTrack
          : (Array.isArray(traced)
            ? traced.map(([la, ln]) => ({ lat: la, lng: ln, ts: Date.now(), acc: 0 }))
            : []);

        const linePts = ensureLineMin2(raw);
        if (linePts.length < 2) { alert('ä½ç½®ãŒå–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸ'); window.__logStartedAt = null; return; }

        let distance_m = 0;
        for (let i = 1; i < linePts.length; i++) {
          const a = linePts[i - 1], b = linePts[i];
          if (a.lat !== b.lat || a.lng !== b.lng) {
            distance_m += (typeof haversine === 'function' ? haversine(a, b) : 0);
          }
        }
        distance_m = Math.round(distance_m);

        const startTs = linePts[0].ts || (window.__logStartedAt || Date.now());
        const endTs = linePts[linePts.length - 1].ts || Date.now();
        const duration_s = Math.max(1, ((endTs - startTs) / 1000) | 0);

        const coords = linePts.map((p) => [p.lng, p.lat]);
        const gj = { type: 'LineString', coordinates: coords };
        const poly = encodePolyline(linePts.map((p) => [p.lat, p.lng]));

        const today = new Date(endTs);
        const nameDefault = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')} å®Ÿèµ°`;
        const name = typeof prompt === 'function' ? (prompt('å®Ÿèµ°ãƒ­ã‚°å', nameDefault) || nameDefault) : nameDefault;

        const payload = {
          account_id: accountId,
          name,
          started_at: new Date(startTs).toISOString(),
          ended_at: new Date(endTs).toISOString(),
          distance_m,
          duration_s,
          geojson: gj,
          polyline: poly
        };

        let redirected = false;
        try {
          console.log('RUN INSERT payload', payload);
          const { data: newRow, error, status } = await supabase
            .from('runs')
            .insert([payload])
            .select('id')
            .maybeSingle();

          if (error || !newRow) {
            console.error('RUN INSERT ERROR', { status, error, payload });
            alert(`ä¿å­˜ã«å¤±æ•—: ${status || ''} ${error?.message || ''}`);
            return;
          }

          location.href = `detail.html?id=${encodeURIComponent(newRow.id)}&kind=run&v=${V()}`;
          redirected = true;
          return;
        } catch (e) {
          console.error('RUN SAVE EXCEPTION', e);
          alert('ä¿å­˜ã«å¤±æ•—: ' + (e?.message || 'ä¸æ˜ãªã‚¨ãƒ©ãƒ¼'));
        } finally {
          window.__logStartedAt = null;
          try { layerOn?.remove(); layerOn = null; layerOff?.remove(); layerOff = null; } catch (_) { }
          if (!redirected) { await renderLogs(); setTab('logs'); }
        }
      });

      followBtn.addEventListener('click', () => {
        follow = !follow;
        followBtn.textContent = follow ? 'ğŸ” è¿½å¾“ ON' : 'ğŸ” è¿½å¾“ OFF';
      });

      locateBtn.addEventListener('click', () => {
        if (!('geolocation' in navigator)) {
          alert('ã“ã®ç«¯æœ«ã§ã¯ä½ç½®æƒ…å ±ãŒä½¿ãˆã¾ã›ã‚“');
          return;
        }
        clearWatchIfAny();
        follow = true;
        followBtn.textContent = 'ğŸ” è¿½å¾“ ON';
        _watchId = navigator.geolocation.watchPosition(onPos, onErr, GEO_OPTIONS);
      });

      editToggleBtn.addEventListener('click', () => {
        if (recording) {
          alert('è¨˜éŒ²ä¸­ã¯ç·¨é›†ã§ãã¾ã›ã‚“');
          return;
        }
        setEditMode(!editMode);
      });

      backLogsBtn.addEventListener('click', () => {
        setTab('logs');
      });

      tabLogs.addEventListener('click', () => setTab('logs'));
      tabRun.addEventListener('click', () => {
        setTab('run');
        resetRunLayers();
      });

      const safeRender = async () => {
        try {
          await withTimeout(renderAuthBar(), 2500, 'renderAuthBar timeout');
        } catch (e) {
          console.error('renderAuthBar failure', e);
          const el = document.getElementById('authBar');
          if (el) el.textContent = `èªè¨¼çŠ¶æ…‹ã®å–å¾—ã«å¤±æ•—/ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆï¼š${e?.message || e}`;
        }
        try {
          await renderLogs();
        } catch (e) {
          console.error('renderLogs failure', e);
          if (logsList) logsList.textContent = 'ãƒ­ã‚°ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ';
        }
      };

      await safeRender();

      supabase.auth.onAuthStateChange(async (_event, session) => {
        await safeRender();
        if (session?.user) {
          plannedRouteLoaded = false;
          await loadPlannedRouteIfAny(true);
        }
      });
      window.addEventListener('pageshow', async () => {
        try {
          await safeRender();
          if (map) {
            plannedRouteLoaded = false;
            await loadPlannedRouteIfAny(true);
          }
        } catch (e) {
          console.warn('pageshow refresh error', e);
        }
      });
      window.addEventListener('pagehide', cleanupRun, { passive: true });
      window.addEventListener('beforeunload', cleanupRun);
      if (canUseWakeLock()) {
        document.addEventListener('visibilitychange', async () => {
          if (document.visibilityState === 'visible' && recording) {
            await requestWakeLock();
          } else {
            await releaseWakeLock();
          }
        }, { passive: true });
      }

      if (initialRouteId) {
        try {
          document.querySelector('#tabRun')?.click();
          await loadPlannedRouteIfAny(true);
        } catch (e) {
          console.warn('initial route load failed', e);
        }
      } else {
        setTab('logs');
      }
    }
    document.addEventListener('DOMContentLoaded', () => startApp('dcl'));
    setTimeout(() => startApp('fallback'), 4000);
  </script>
  <script>
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register(`./service-worker.js?v=${encodeURIComponent(window.APP_VERSION || '')}`)
        .catch(err => console.error('SW register failed', err));
    }
  </script>
</body>

</html>
