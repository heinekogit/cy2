<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Route MVP â€“ å®Ÿèµ°è¨˜éŒ²</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="" />
  <script src="js/version.js"></script>
  <script>
    if (typeof window.APP_VERSION === 'undefined' || !window.APP_VERSION) {
      window.APP_VERSION = new Date().toISOString().slice(0, 10) + '-dev';
    }
  </script>
  <style>
    :root { --bg:#fff; --fg:#111827; --muted:#6b7280; --accent:#111827; --ok:#065f46; --okbg:#d1fae5; --warn:#92400e; --warnbg:#fef3c7; --off:#991b1b; --offbg:#fee2e2; }
    html,body { height:100%; margin:0; background:var(--bg); color:var(--fg); font-family: system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans JP"; }
    #app { height:100%; display:flex; flex-direction:column; }
    header { padding:10px 12px; border-bottom:1px solid #e5e7eb; display:flex; align-items:center; justify-content:space-between; gap:8px; }
    header .tabs { display:flex; gap:8px; flex-wrap:wrap; }
    .tab { padding:8px 12px; border-radius:999px; border:1px solid #e5e7eb; cursor:pointer; background:#fff; }
    .tab.active { background:#111827; color:#fff; border-color:#111827; }
    .btn { border:none; border-radius:10px; padding:8px 10px; font-size:14px; cursor:pointer; display:inline-flex; align-items:center; justify-content:center; gap:4px; text-decoration:none; }
    .btn.ghost { background:#fff; color:#111827; border:1px solid #e5e7eb; }
    .btn.primary { background:#111827; color:#fff; }
    .btn.danger { background:#ef4444; color:#fff; }
    .btn.big { padding:12px 14px; font-weight:700; }
    main { flex:1; display:flex; }
    .panel { flex:1; display:none; }
    .panel.active { display:flex; }
    #logsSection { flex-direction:column; }
    .list { padding:12px; display:flex; flex-direction:column; gap:10px; overflow:auto; }
    .card { border:1px solid #e5e7eb; border-radius:12px; padding:10px 12px; display:flex; justify-content:space-between; align-items:flex-start; gap:12px; background:#fff; }
    .card.highlight { outline:3px solid #93c5fd; }
    .meta { font-size:12px; color:var(--muted); }
    #runSection { position:relative; display:none; }
    #runSection.active { display:block; }
    #map { position:absolute; inset:0; }
    .badgewrap { position:fixed; left:8px; right:8px; top:env(safe-area-inset-top,8px); display:flex; gap:8px; z-index:1000; }
    .badge { padding:6px 10px; border-radius:999px; font-weight:600; background:#e2e8f0; }
    .badge.ok { background:var(--okbg); color:var(--ok); }
    .badge.warn { background:var(--warnbg); color:var(--warn); }
    .badge.off { background:var(--offbg); color:var(--off); }
    .dock { position:fixed; right:8px; bottom:8px; display:flex; flex-direction:column; gap:8px; z-index:1000; }
    .toolbar { position:fixed; left:8px; bottom:8px; z-index:1000; display:flex; gap:8px; }
    .toast { position:fixed; left:50%; transform:translateX(-50%); bottom:20px; background:#111827; color:#fff; padding:10px 14px; border-radius:10px; z-index:1100; display:none; }
    .hint { position:fixed; left:8px; bottom:60px; background:#ffffffd8; padding:6px 10px; border-radius:10px; font-size:12px; z-index:999; }
    .auth-card { margin:10px 12px 0; padding:10px 12px; border:1px solid #e5e7eb; border-radius:10px; background:#fff; }
    footer { padding:6px 10px; font-size:12px; color:var(--muted); border-top:1px solid #e5e7eb; }
    @media (max-width:600px) {
      header { flex-direction:column; align-items:flex-start; }
      .dock { flex-direction:column; right:4px; bottom:4px; }
      .toolbar { left:4px; bottom:4px; }
    }
  </style>
</head>
<body>
  <div id="app">
    <header>
      <div style="font-weight:700;">Route MVP</div>
      <div class="tabs">
        <button id="tabLogs" class="tab active" type="button">ãƒ­ã‚°ä¸€è¦§</button>
        <button id="tabRun" class="tab" type="button">å®Ÿèµ°ã™ã‚‹</button>
      </div>
      <div style="display:flex; gap:6px; flex-wrap:wrap;">
        <a id="lnHome" class="btn ghost" href="index.html">å…¬é–‹ãƒ«ãƒ¼ãƒˆ</a>
        <a id="lnMyPage" class="btn ghost" href="mypage.html">ãƒã‚¤ãƒšãƒ¼ã‚¸</a>
      </div>
    </header>

    <div id="authBar" class="auth-card">èªè¨¼çŠ¶æ…‹ã‚’ç¢ºèªä¸­â€¦</div>

    <main>
      <section id="logsSection" class="panel active" aria-label="logs">
        <div id="logsList" class="list">èª­ã¿è¾¼ã¿ä¸­â€¦</div>
      </section>
      <section id="runSection" class="panel" aria-label="run">
        <div id="map"></div>
        <div class="badgewrap"><div id="courseBadge" class="badge">æº–å‚™ä¸­â€¦</div></div>
        <div class="dock">
          <button id="startBtn" class="btn primary big" type="button">â–¶ è¨˜éŒ²é–‹å§‹</button>
          <button id="stopBtn" class="btn danger big" type="button">â–  åœæ­¢</button>
          <button id="followBtn" class="btn ghost" type="button">ğŸ” è¿½å¾“ OFF</button>
          <button id="locateBtn" class="btn ghost" type="button">ğŸ“ ç¾åœ¨åœ°ã ã‘</button>
          <button id="backLogsBtn" class="btn ghost" type="button">ğŸ“„ ãƒ­ã‚°ä¸€è¦§ã¸</button>
        </div>
        <div class="toolbar"><button id="editToggleBtn" class="btn ghost" type="button">âœï¸ ç·¨é›†ãƒ¢ãƒ¼ãƒ‰</button></div>
        <div id="hint" class="hint">â–¶ã§GPS+è¨˜éŒ²+è¿½å¾“ONã€‚â– åœæ­¢ã§ä¿å­˜ç¢ºèªâ†’ä¿å­˜å¾Œã¯ãƒ­ã‚°ä¸€è¦§ã¸ã€‚</div>
        <div id="toast" class="toast"></div>
      </section>
    </main>

    <footer class="muted">v: <code id="ver"></code></footer>
  </div>

  <script>
    document.getElementById('ver').textContent = window.APP_VERSION;
  </script>
  <script src="https://unpkg.com/@supabase/supabase-js@2/dist/umd/supabase.js"></script>
  <script>
    (function(){
      const supabaseLib = window.supabase;
      const SUPABASE_URL = 'https://cqiqhczxuiyakptdjowr.supabase.co';
      const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNxaXFoY3p4dWl5YWtwdGRqb3dyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTc3NzAwNzMsImV4cCI6MjA3MzM0NjA3M30.vCFQoQnsClINKa5tQAz-rNnF5XLEukmn_Nl0Err5k3k';
      const client = supabaseLib.createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
        auth: { persistSession: true, autoRefreshToken: true, detectSessionInUrl: false }
      });
      window.supabaseClient = client;
      window.supabase = client;
    })();
  </script>

  <!-- âœ… ã“ã“ã‹ã‚‰å…±é€šåŒ–ãƒ‘ãƒ¼ãƒˆ -->
  <script src="js/auth-common.js"></script>
  <script>
    AuthCommon.init(window.supabase, { redirectUrl: 'index.html' });
    window.getMyAccountId = () => AuthCommon.getMyAccountId(window.supabase);
  </script>

  <script>
    (function() {
      const version = encodeURIComponent(window.APP_VERSION || '');
      document.write(`<script src="js/storage.js?v=${version}"><\/script>`);
    })();
  </script>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6.5.0/turf.min.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', async () => {
      const supabase = window.supabase;
      const V = () => encodeURIComponent(window.APP_VERSION || '');

      const tabLogs = document.getElementById('tabLogs');
      const tabRun = document.getElementById('tabRun');
      const logsSection = document.getElementById('logsSection');
      const runSection = document.getElementById('runSection');
      const logsList = document.getElementById('logsList');
      const authBar = document.getElementById('authBar');
      const startBtn = document.getElementById('startBtn');
      const stopBtn = document.getElementById('stopBtn');
      const followBtn = document.getElementById('followBtn');
      const locateBtn = document.getElementById('locateBtn');
      const backLogsBtn = document.getElementById('backLogsBtn');
      const editToggleBtn = document.getElementById('editToggleBtn');
      const toastEl = document.getElementById('toast');
      const hintEl = document.getElementById('hint');
      const badgeEl = document.getElementById('courseBadge');
      const lnHome = document.getElementById('lnHome');
      const lnMyPage = document.getElementById('lnMyPage');
      if (lnHome) lnHome.href = `index.html?v=${V()}`;
      if (lnMyPage) lnMyPage.href = `mypage.html?v=${V()}`;

      let map;
      let routePts = [];
      let routeLine;
      let editMode = false;
      let recording = false;
      let follow = false;
      let dot = null;
      let accCircle = null;
      let lastLatLng = null;
      let traced = [];
      let tracedLine = null;
      let lastAddTs = 0;
      let lastSavedLogId = null;
      let isLoggedIn = false;
      let rawTrack = [];

      // è¿½å¾“ãƒ«ãƒ¼ãƒˆï¼†ãƒ©ã‚¤ãƒ³ãƒ¬ã‚¤ãƒ¤
      let planned = [];        // äºˆå®šãƒ«ãƒ¼ãƒˆï¼ˆ{lat,lng}[]ï¼‰
      let plannedLayer = null; // äºˆå®šãƒ©ã‚¤ãƒ³ï¼ˆé’ï¼‰
      let layerOn = null;      // å®Ÿèµ°ã‚ªãƒ³ãƒ«ãƒ¼ãƒˆï¼ˆç·‘ï¼‰
      let layerOff = null;     // å®Ÿèµ°é€¸è„±ï¼ˆèµ¤ï¼‰

      const ACC_LIMIT = 100;
      const MIN_MOVE = 3;
      const MIN_INTERVAL_MS = 1000;
      const GEO_OPTIONS = { enableHighAccuracy: true, maximumAge: 0, timeout: 20000 };
      const COLORS = {
        planned: '#3b82f6',
        liveOn: '#10b981',
        liveOff: '#ef4444'
      };
      const OFF_THRESHOLD_M = 30;

      const decodePolyline = (str) => {
        try {
          let idx = 0, lat = 0, lng = 0;
          const out = [];
          while (idx < str.length) {
            let b, shift = 0, result = 0;
            do {
              b = str.charCodeAt(idx++) - 63;
              result |= (b & 0x1f) << shift;
              shift += 5;
            } while (b >= 0x20);
            const dlat = (result & 1) ? ~(result >> 1) : (result >> 1);
            shift = 0;
            result = 0;
            do {
              b = str.charCodeAt(idx++) - 63;
              result |= (b & 0x1f) << shift;
              shift += 5;
            } while (b >= 0x20);
            const dlng = (result & 1) ? ~(result >> 1) : (result >> 1);
            lat += dlat;
            lng += dlng;
            out.push({ lat: lat / 1e5, lng: lng / 1e5 });
          }
          return out;
        } catch (e) {
          console.warn('decodePolyline error', e);
          return [];
        }
      };

      const escapeHtml = (str) => (str ?? '').replace(/[&<>"']/g, (c) => ({
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;'
      })[c] || c);
      const fmtDateTime = (v) => v ? new Date(v).toLocaleString() : '-';
      const fmtDistance = (m) => (m ? `${(m / 1000).toFixed(2)} km` : '-');
      const fmtDuration = (sec) => {
        if (!sec && sec !== 0) return '-';
        const h = Math.floor(sec / 3600);
        const m = Math.floor((sec % 3600) / 60);
        const s = sec % 60;
        return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
      };
      const showToast = (msg) => {
        toastEl.textContent = msg;
        toastEl.style.display = 'block';
        setTimeout(() => { toastEl.style.display = 'none'; }, 2000);
      };
      const setBadge = (state, text) => {
        badgeEl.className = `badge ${state || ''}`.trim();
        badgeEl.textContent = text;
      };

      function setTab(tab) {
        const showRun = tab === 'run';
        tabLogs.classList.toggle('active', !showRun);
        tabRun.classList.toggle('active', showRun);
        logsSection.classList.toggle('active', !showRun);
        runSection.classList.toggle('active', showRun);
        logsSection.style.display = showRun ? 'none' : 'flex';
        runSection.style.display = showRun ? 'block' : 'none';
        if (showRun) {
          initMapOnce();
          loadPlannedRouteIfAny();
          clearLiveLayers();
          setTimeout(() => { map && map.invalidateSize(true); }, 120);
        } else {
          clearWatchIfAny();
          recording = false;
          setBadge('', 'è¨˜éŒ²åœæ­¢');
        }
      }

      async function renderAuthBar() {
        try {
          const { data: { session } } = await supabase.auth.getSession();
          const loginUrl = `login.html?v=${V()}`;
          const myPageUrl = `mypage.html?v=${V()}`;
          if (!session?.user) {
            isLoggedIn = false;
            authBar.innerHTML = `
              æœªãƒ­ã‚°ã‚¤ãƒ³ã§ã™ã€‚ãƒ­ã‚°ã‚’ä¿å­˜ã™ã‚‹ã«ã¯ <a class="btn ghost" href="${loginUrl}">ãƒ­ã‚°ã‚¤ãƒ³</a> ã—ã¦ãã ã•ã„ã€‚
            `;
            startBtn.disabled = true;
            stopBtn.disabled = true;
        } else {
          isLoggedIn = true;
          const email = session.user.email || '';
          authBar.innerHTML = `
            ãƒ­ã‚°ã‚¤ãƒ³ä¸­: <strong>${escapeHtml(email)}</strong>
            <div style="margin-top:6px; display:flex; gap:6px; flex-wrap:wrap;">
              <a class="btn ghost" href="${myPageUrl}">ãƒã‚¤ãƒšãƒ¼ã‚¸ã¸</a>
              <button class="btn ghost" data-signout type="button">ã‚µã‚¤ãƒ³ã‚¢ã‚¦ãƒˆ</button>
            </div>
          `;
          startBtn.disabled = false;
          stopBtn.disabled = false;
        }
      } catch (e) {
        console.error('renderAuthBar error', e);
        authBar.textContent = 'èªè¨¼çŠ¶æ…‹ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ';
      }
      }

      async function renderLogs() {
        logsList.textContent = 'èª­ã¿è¾¼ã¿ä¸­â€¦';
        try {
          const logs = await window.dbGetAll('logs');
          if (!logs || logs.length === 0) {
            logsList.innerHTML = '<div class="meta">ä¿å­˜ã•ã‚ŒãŸå®Ÿèµ°ãƒ­ã‚°ã¯ã¾ã ã‚ã‚Šã¾ã›ã‚“ã€‚è¨˜éŒ²é–‹å§‹ãƒœã‚¿ãƒ³ã‹ã‚‰å®Ÿèµ°ã‚’è¨˜éŒ²ã—ã¦ãã ã•ã„ã€‚</div>';
            return;
          }
          logsList.innerHTML = '';
          for (const log of logs) {
            const card = document.createElement('div');
            card.className = 'card';
          if (lastSavedLogId && log.id === lastSavedLogId) {
            card.classList.add('highlight');
            setTimeout(() => {
              card.classList.remove('highlight');
              lastSavedLogId = null;
            }, 2500);
            }
            card.innerHTML = `
              <div style="flex:1 1 auto;">
                <div style="font-weight:600;">${escapeHtml(log.name || '(ç„¡é¡Œãƒ­ã‚°)')} <span class="meta">#${log.id}</span></div>
                <div class="meta">${fmtDateTime(log.startedAt)} â†’ ${fmtDateTime(log.endedAt)}</div>
                <div class="meta">${fmtDistance(log.distanceMeters)} / ${fmtDuration(log.durationSec)}</div>
              </div>
              <div style="display:flex; gap:6px; flex-wrap:wrap;">
                <a class="btn ghost" href="detail.html?id=${encodeURIComponent(log.id)}&kind=run&v=${V()}">è©³ç´°</a>
                <button class="btn danger" data-del="${log.id}" type="button">å‰Šé™¤</button>
              </div>
            `;
            logsList.appendChild(card);
          }
          logsList.querySelectorAll('button[data-del]').forEach((btn) => {
            btn.onclick = async () => {
              const id = Number(btn.getAttribute('data-del'));
              if (!Number.isFinite(id)) return;
              if (!confirm('ã“ã®å®Ÿèµ°ãƒ­ã‚°ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ')) return;
              try {
                await window.dbDelete('logs', id);
                showToast('å‰Šé™¤ã—ã¾ã—ãŸ');
              } catch (e) {
                console.error('delete log error', e);
                alert('å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ');
              } finally {
                await renderLogs();
              }
            };
          });
        } catch (e) {
          console.error('renderLogs error', e);
          logsList.textContent = 'ãƒ­ã‚°ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ';
        }
      }

      let _watchId = null;

      const clearWatchIfAny = () => {
        if (_watchId != null) {
          navigator.geolocation.clearWatch(_watchId);
          _watchId = null;
        }
      };

      function initMapOnce() {
        if (map) return;
        map = L.map('map').setView([35.681236, 139.767125], 14);
        L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
          maxZoom: 19,
          attribution: '&copy; OpenStreetMap contributors'
        }).addTo(map);
        routeLine = L.polyline(routePts, { color: '#2563eb', weight: 4 }).addTo(map);
        ensureLiveLayers();
        setBadge('', 'âœï¸ã§ãƒ«ãƒ¼ãƒˆç·¨é›†ã€â–¶ã§è¨˜éŒ²é–‹å§‹');
        map.on('click', (e) => {
          if (!editMode || recording) return;
          routePts.push([e.latlng.lat, e.latlng.lng]);
          routeLine.setLatLngs(routePts);
          if (routePts.length > 1) {
            map.fitBounds(routeLine.getBounds(), { padding: [24, 24] });
          }
          if (lastLatLng) updateCourseStatus(lastLatLng);
        });
        loadPlannedRouteIfAny();
      }

      let plannedRouteLoaded = false;
      const initialRouteId = (() => {
        const val = new URL(location.href).searchParams.get('route');
        if (val == null) return null;
        const num = Number(val);
        return Number.isFinite(num) ? num : null;
      })();

      async function loadPlannedRouteIfAny(force = false) {
        if (!map) return;
        try {
          const rid = initialRouteId;
          if (!rid) {
            planned = [];
            if (plannedLayer) {
              plannedLayer.remove();
              plannedLayer = null;
            }
            plannedRouteLoaded = false;
            return;
          }
          if (plannedRouteLoaded && !force) return;
          const { data: route, error } = await supabase
            .from('routes')
            .select('*')
            .eq('id', rid)
            .maybeSingle();
          if (error || !route) return;

          const pts = extractLatLngsFromRoute(route);
          if (!pts.length) return;
          planned = pts;
          plannedRouteLoaded = true;

          if (plannedLayer) {
            plannedLayer.remove();
            plannedLayer = null;
          }
          plannedLayer = L.polyline(planned.map(p => [p.lat, p.lng]), { color: COLORS.planned, weight: 5 }).addTo(map);
          plannedLayer.bringToBack();
          ensureLiveLayers();
          layerOn.bringToFront();
          layerOff.bringToFront();
          map.fitBounds(plannedLayer.getBounds(), { padding: [24, 24], maxZoom: 16 });
          setBadge('', 'äºˆå®šãƒ«ãƒ¼ãƒˆèª­è¾¼æ¸ˆã¿ï¼ˆé’ï¼‰ï¼â–¶ã§è¨˜éŒ²é–‹å§‹');
        } catch (e) {
          console.warn('loadPlannedRouteIfAny', e);
        }
      }

      function extractLatLngsFromRoute(route) {
        try {
          if (route.geojson) {
            const g = typeof route.geojson === 'string' ? JSON.parse(route.geojson) : route.geojson;
            const out = [];
            const walk = (geom) => {
              if (!geom) return;
              const t = geom.type;
              const co = geom.coordinates;
              if (t === 'LineString') co.forEach(([lng, lat]) => out.push({ lat, lng }));
              else if (t === 'MultiLineString') co.forEach(line => line.forEach(([lng, lat]) => out.push({ lat, lng })));
              else if (t === 'GeometryCollection') (geom.geometries || []).forEach(walk);
            };
            if (g.type === 'Feature') walk(g.geometry);
            else if (g.type === 'FeatureCollection') (g.features || []).forEach(f => walk(f.geometry));
            else walk(g);
            if (out.length) return out;
          }
        } catch (e) {
          console.warn('extractLatLngsFromRoute geojson', e);
        }
        if (route.polyline) {
          return decodePolyline(route.polyline);
        }
        return [];
      }

      function currentFollowLineLatLngs() {
        if (planned && planned.length >= 2) return planned.map(p => [p.lat, p.lng]);
        return (routePts && routePts.length >= 2) ? routePts.map(([la, ln]) => [la, ln]) : [];
      }

      function ensureLiveLayers() {
        if (!map) return;
        if (!layerOn) layerOn = L.polyline([], { color: COLORS.liveOn, weight: 5 }).addTo(map);
        if (!layerOff) layerOff = L.polyline([], { color: COLORS.liveOff, weight: 5 }).addTo(map);
      }

      function clearLiveLayers() {
        if (!map) return;
        ensureLiveLayers();
        if (layerOn) {
          layerOn.setLatLngs([]);
          layerOn.bringToFront();
        }
        if (layerOff) {
          layerOff.setLatLngs([]);
          layerOff.bringToFront();
        }
      }

      const cleanupRun = () => {
        try { clearWatchIfAny(); } catch (_) {}
        try { clearLiveLayers(); } catch (_) {}
        recording = false;
        traced = [];
        lastAddTs = 0;
        plannedRouteLoaded = false;
        rawTrack = [];
      };

      const m2deg = (m) => m / 111320;
      const encodePolyline = (latlngs) => {
        try {
          let lastLat = 0;
          let lastLng = 0;
          let res = '';
          for (const [lat, lng] of latlngs) {
            let iLat = Math.round(lat * 1e5);
            let iLng = Math.round(lng * 1e5);
            let dLat = iLat - lastLat;
            let dLng = iLng - lastLng;
            for (let v of [dLat, dLng]) {
              v = v < 0 ? ~(v << 1) : v << 1;
              while (v >= 0x20) {
                res += String.fromCharCode((0x20 | (v & 0x1f)) + 63);
                v >>= 5;
              }
              res += String.fromCharCode(v + 63);
            }
            lastLat = iLat;
            lastLng = iLng;
          }
          return res;
        } catch (e) {
          console.error('encodePolyline error', e);
          return '';
        }
      };
      const movingAverage = (latlngs) => {
        if (latlngs.length < 3) return latlngs.slice();
        const out = latlngs.map((p) => p.slice());
        for (let i = 1; i < latlngs.length - 1; i++) {
          out[i][0] = (latlngs[i - 1][0] + latlngs[i][0] + latlngs[i + 1][0]) / 3;
          out[i][1] = (latlngs[i - 1][1] + latlngs[i][1] + latlngs[i + 1][1]) / 3;
        }
        return out;
      };
      const dedupeTinyMoves = (latlngs) => {
        if (latlngs.length < 2) return latlngs.slice();
        const out = [latlngs[0]];
        for (let i = 1; i < latlngs.length; i++) {
          const a = L.latLng(out[out.length - 1][0], out[out.length - 1][1]);
          const b = L.latLng(latlngs[i][0], latlngs[i][1]);
          if (a.distanceTo(b) >= 2) out.push(latlngs[i]);
        }
        return out;
      };
      const resampleByDistance = (latlngs, stepMeters) => {
        if (latlngs.length < 2) return latlngs.slice();
        const ls = turf.lineString(latlngs.map(([la, ln]) => [ln, la]));
        const lenKm = turf.length(ls, { units: 'kilometers' });
        const stepKm = stepMeters / 1000;
        const pts = [];
        for (let d = 0; d <= lenKm; d += stepKm) {
          const p = turf.along(ls, d, { units: 'kilometers' });
          const [lng, lat] = p.geometry.coordinates;
          pts.push([lat, lng]);
        }
        return pts.length ? pts : latlngs.slice();
      };

const updateCourseStatus = (latlng) => {
  const ref = currentFollowLineLatLngs();
  if (!ref.length) {
    setBadge('', 'ãƒ«ãƒ¼ãƒˆæœªè¨­å®š');
    return;
  }
  try {
    const point = turf.point([latlng.lng, latlng.lat]);
    const line = turf.lineString(ref.map(([la, ln]) => [ln, la]));
    const d = turf.pointToLineDistance(point, line, { units: 'meters' });
    if (d <= OFF_THRESHOLD_M) setBadge('ok', `ON COURSEï¼ˆ~${Math.round(d)}mï¼‰`);
    else if (d <= OFF_THRESHOLD_M * 2) setBadge('warn', `æ³¨æ„ï¼š${Math.round(d)}må¤–`);
    else setBadge('off', `ãƒ«ãƒ¼ãƒˆå¤–ï¼š${Math.round(d)}m`);
  } catch (e) {
    console.error('updateCourseStatus error', e);
    setBadge('', 'ãƒ«ãƒ¼ãƒˆåˆ¤å®šã‚¨ãƒ©ãƒ¼');
  }
};

      const resetRunLayers = () => {
        if (!map) return;
        if (tracedLine) {
          map.removeLayer(tracedLine);
          tracedLine = null;
        }
        traced = [];
        lastAddTs = 0;
        recording = false;
        setEditMode(false);
        clearLiveLayers();
        const hasReference = currentFollowLineLatLngs().length >= 2;
        setBadge('', hasReference ? 'äºˆå®šãƒ«ãƒ¼ãƒˆèª­è¾¼æ¸ˆã¿ï¼ˆé’ï¼‰ï¼â–¶ã§è¨˜éŒ²é–‹å§‹' : 'âœï¸ã§ãƒ«ãƒ¼ãƒˆç·¨é›†ã€â–¶ã§è¨˜éŒ²é–‹å§‹');
      };

      const setEditMode = (on) => {
        editMode = !!on;
        if (editToggleBtn) {
          editToggleBtn.textContent = editMode ? 'âœ… ç·¨é›†çµ‚äº†ï¼ˆãƒ­ãƒƒã‚¯ï¼‰' : 'âœï¸ ç·¨é›†ãƒ¢ãƒ¼ãƒ‰';
        }
        if (hintEl) {
          hintEl.textContent = editMode
            ? 'ãƒ«ãƒ¼ãƒˆã«æ²¿ã£ã¦åœ°å›³ã‚’ã‚¿ãƒƒãƒ—ã—ã¦ãƒã‚¤ãƒ³ãƒˆã‚’è¿½åŠ ã§ãã¾ã™ã€‚'
            : 'â–¶ã§GPS+è¨˜éŒ²+è¿½å¾“ONã€‚â– åœæ­¢ã§ä¿å­˜ç¢ºèªâ†’ä¿å­˜å¾Œã¯ãƒ­ã‚°ä¸€è¦§ã¸ã€‚';
        }
      };

      const onPos = (pos) => {
        const { latitude: lat, longitude: lng, accuracy: acc } = pos.coords;
        const latlng = L.latLng(lat, lng);
        lastLatLng = latlng;
        ensureLiveLayers();
        if (!dot) {
          dot = L.circleMarker(latlng, { radius: 6, weight: 2, color: '#2563eb', fillColor: '#3b82f6', fillOpacity: 1 }).addTo(map);
          accCircle = L.circle(latlng, { radius: acc, color: '#93c5fd', weight: 1, fillColor: '#bfdbfe', fillOpacity: 0.25 }).addTo(map);
        } else {
          dot.setLatLng(latlng);
          accCircle.setLatLng(latlng).setRadius(acc);
        }
        if (follow) map.panTo(latlng, { animate: true });

        const now = Date.now();
        if (recording && acc <= ACC_LIMIT && (now - lastAddTs) >= MIN_INTERVAL_MS) {
          const prev = traced[traced.length - 1];
          const moved = !prev || latlng.distanceTo(L.latLng(prev[0], prev[1])) >= MIN_MOVE;
          if (moved) {
            traced.push([lat, lng]);
            rawTrack.push({ lat, lng, acc, ts: now });
            lastAddTs = now;
            appendLivePoint(lat, lng);
          }
        }
        updateCourseStatus(latlng);
      };

function appendLivePoint(lat, lng) {
  ensureLiveLayers();
  let isOn = true;
  const ref = currentFollowLineLatLngs();
  if (ref.length >= 2) {
          try {
            const point = turf.point([lng, lat]);
            const line = turf.lineString(ref.map(([la, ln]) => [ln, la]));
            const d = turf.pointToLineDistance(point, line, { units: 'meters' });
            isOn = d <= OFF_THRESHOLD_M;
          } catch (e) {
            console.warn('appendLivePoint distance error', e);
          }
        }
        if (isOn) layerOn.addLatLng([lat, lng]);
        else layerOff.addLatLng([lat, lng]);
        layerOn.bringToFront();
  layerOff.bringToFront();
}

function ensureLineMin2(pts) {
  if (!Array.isArray(pts) || pts.length === 0) return [];
  if (pts.length >= 2) return pts;
  const p = pts[0];
  return [p, { lat: p.lat, lng: p.lng, ts: (p.ts || Date.now()) + 1, acc: p.acc || 0 }];
}

      const onErr = (err) => {
        console.warn('geolocation error', err);
        showToast('ä½ç½®æƒ…å ±ã‚¨ãƒ©ãƒ¼');
        clearWatchIfAny();
      };

      startBtn.onclick = () => {
        if (!isLoggedIn) {
          alert('ãƒ­ã‚°ã‚¤ãƒ³å¾Œã«è¨˜éŒ²ã§ãã¾ã™ã€‚å…ˆã«ãƒ­ã‚°ã‚¤ãƒ³ã—ã¦ãã ã•ã„ã€‚');
          return;
        }
        if (!('geolocation' in navigator)) {
          alert('ã“ã®ç«¯æœ«ã§ã¯ä½ç½®æƒ…å ±ãŒä½¿ãˆã¾ã›ã‚“');
          return;
        }
        follow = true;
        followBtn.textContent = 'ğŸ” è¿½å¾“ ON';
        clearWatchIfAny();
        _watchId = navigator.geolocation.watchPosition(onPos, onErr, GEO_OPTIONS);

        setEditMode(false);
        recording = true;
        traced = [];
        lastAddTs = 0;
        rawTrack = [];
        if (tracedLine) {
          map.removeLayer(tracedLine);
          tracedLine = null;
        }
        clearLiveLayers();
        window.__logStartedAt = new Date().toISOString();
        setBadge('warn', 'è¨˜éŒ²ä¸­ï¼šã‚ªãƒ³ã‚³ãƒ¼ã‚¹åˆ¤å®šæœ‰åŠ¹');
        showToast('è¨˜éŒ²ã‚’é–‹å§‹ã—ã¾ã—ãŸ');
      };

      stopBtn.onclick = async () => {
        if (!recording) {
          showToast('è¨˜éŒ²ã¯é–‹å§‹ã•ã‚Œã¦ã„ã¾ã›ã‚“');
          return;
        }
        recording = false;
        clearWatchIfAny();

        const count = traced.length;
        const ok = confirm(`è¨˜éŒ²ã‚’åœæ­¢ã—ã¾ã™ã€‚ãƒ­ã‚°ã‚’ä¿å­˜ã—ã¾ã™ã‹ï¼Ÿï¼ˆãƒã‚¤ãƒ³ãƒˆæ•°: ${count}ï¼‰`);
        if (!ok) {
          setBadge('', 'è¨˜éŒ²åœæ­¢');
          showToast('ä¿å­˜ã›ãšçµ‚äº†');
          window.__logStartedAt = null;
          return;
        }

        const accountId = await (window.getMyAccountId ? window.getMyAccountId() : null);
        if (!accountId) {
          alert('ãƒ­ã‚°ã‚¤ãƒ³ãŒåˆ‡ã‚Œã¾ã—ãŸã€‚å†ãƒ­ã‚°ã‚¤ãƒ³ã—ã¦ãã ã•ã„');
          window.__logStartedAt = null;
          location.replace('index.html?v=' + encodeURIComponent(window.APP_VERSION || ''));
          return;
        }

        const raw = rawTrack.length ? rawTrack : traced.map(([la, ln]) => ({ lat: la, lng: ln, ts: Date.now(), acc: 0 }));
        const linePts = ensureLineMin2(raw);
        if (linePts.length < 2) {
          alert('ä½ç½®ãŒå–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚');
          window.__logStartedAt = null;
          return;
        }

        let distance_m = 0;
        for (let i = 1; i < linePts.length; i++) {
          const a = linePts[i - 1];
          const b = linePts[i];
          distance_m += (a.lat === b.lat && a.lng === b.lng) ? 0 : haversine(a, b);
        }
        distance_m = Math.round(distance_m);

        const startTs = linePts[0].ts || Date.now();
        const endTs = linePts[linePts.length - 1].ts || Date.now();
        const durationSec = Math.max(1, ((endTs - startTs) / 1000) | 0);

        const coords = linePts.map(p => [p.lng, p.lat]);
        const gj = { type: 'LineString', coordinates: coords };

        const today = new Date();
        const nameDefault = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')} å®Ÿèµ°`;
        const name = prompt('å®Ÿèµ°ãƒ­ã‚°ã®åå‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„', nameDefault) || nameDefault;

        const record = {
          accountId,
          name,
          startedAt: new Date(startTs).toISOString(),
          endedAt: new Date(endTs).toISOString(),
          polyline: encodePolyline(linePts.map(p => [p.lat, p.lng])),
          geojson: gj,
          pointCount: linePts.length,
          distanceMeters: distance_m,
          durationSec,
          bbox: null,
          routeId: planned && planned.length && initialRouteId ? initialRouteId : null
        };

        let redirected = false;
        try {
          console.log('å®Ÿèµ°ãƒ­ã‚°ã‚’ä¿å­˜ã—ã¾ã™', record);
          const saved = await window.dbPut('logs', record);
          if (saved?.id) {
            location.href = `detail.html?id=${encodeURIComponent(saved.id)}&kind=run&v=${V()}`;
            redirected = true;
            return;
          }
          lastSavedLogId = saved?.id ?? null;
          showToast('ä¿å­˜ã—ã¾ã—ãŸ');
        } catch (e) {
          console.error('RUN SAVE ERROR', e, record);
          alert('ä¿å­˜ã«å¤±æ•—: ' + (e?.message || 'ä¸æ˜ãªã‚¨ãƒ©ãƒ¼'));
          window.__logStartedAt = null;
          return;
        } finally {
          window.__logStartedAt = null;
          if (!redirected) {
            await renderLogs();
            setTab('logs');
          }
        }
      };

      followBtn.onclick = () => {
        follow = !follow;
        followBtn.textContent = follow ? 'ğŸ” è¿½å¾“ ON' : 'ğŸ” è¿½å¾“ OFF';
      };

      locateBtn.onclick = () => {
        if (!('geolocation' in navigator)) {
          alert('ã“ã®ç«¯æœ«ã§ã¯ä½ç½®æƒ…å ±ãŒä½¿ãˆã¾ã›ã‚“');
          return;
        }
        clearWatchIfAny();
        follow = true;
        followBtn.textContent = 'ğŸ” è¿½å¾“ ON';
        _watchId = navigator.geolocation.watchPosition(onPos, onErr, GEO_OPTIONS);
      };

      editToggleBtn.onclick = () => {
        if (recording) {
          alert('è¨˜éŒ²ä¸­ã¯ç·¨é›†ã§ãã¾ã›ã‚“');
          return;
        }
        setEditMode(!editMode);
      };

      backLogsBtn.onclick = () => {
        setTab('logs');
      };

      tabLogs.onclick = () => setTab('logs');
      tabRun.onclick = () => {
        setTab('run');
        resetRunLayers();
      };

      const safeRender = async () => {
        try {
          await renderAuthBar();
        } catch (e) {
          console.error('renderAuthBar failure', e);
          if (authBar) authBar.textContent = 'èªè¨¼çŠ¶æ…‹ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ';
        }
        try {
          await renderLogs();
        } catch (e) {
          console.error('renderLogs failure', e);
          if (logsList) logsList.textContent = 'ãƒ­ã‚°ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ';
        }
      };

      await safeRender();

      supabase.auth.onAuthStateChange(async (_event, session) => {
        await safeRender();
        if (session?.user) {
          plannedRouteLoaded = false;
          await loadPlannedRouteIfAny(true);
        }
      });
      window.addEventListener('pageshow', async () => {
        try {
          await safeRender();
          if (map) {
            plannedRouteLoaded = false;
            await loadPlannedRouteIfAny(true);
          }
        } catch (e) {
          console.warn('pageshow refresh error', e);
        }
      });
      window.addEventListener('pagehide', cleanupRun, { passive: true });
      window.addEventListener('beforeunload', cleanupRun);

      setTab('logs');
    });
  </script>
  <script>
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register(`./service-worker.js?v=${encodeURIComponent(window.APP_VERSION || '')}`)
        .catch(err => console.error('SW register failed', err));
    }
  </script>
</body>
</html>
