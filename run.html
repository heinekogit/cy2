<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Route MVP – 実走記録</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="" />
  <script src="js/version.js"></script>
  <script>
    if (typeof window.APP_VERSION === 'undefined' || !window.APP_VERSION) {
      window.APP_VERSION = new Date().toISOString().slice(0, 10) + '-dev';
    }
  </script>
  <style>
    :root { --bg:#fff; --fg:#111827; --muted:#6b7280; --accent:#111827; --ok:#065f46; --okbg:#d1fae5; --warn:#92400e; --warnbg:#fef3c7; --off:#991b1b; --offbg:#fee2e2; }
    html,body { height:100%; margin:0; background:var(--bg); color:var(--fg); font-family: system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans JP"; }
    #app { height:100%; display:flex; flex-direction:column; }
    header { padding:10px 12px; border-bottom:1px solid #e5e7eb; display:flex; align-items:center; justify-content:space-between; gap:8px; }
    header .tabs { display:flex; gap:8px; flex-wrap:wrap; }
    .tab { padding:8px 12px; border-radius:999px; border:1px solid #e5e7eb; cursor:pointer; background:#fff; }
    .tab.active { background:#111827; color:#fff; border-color:#111827; }
    .btn { border:none; border-radius:10px; padding:8px 10px; font-size:14px; cursor:pointer; display:inline-flex; align-items:center; justify-content:center; gap:4px; text-decoration:none; }
    .btn.ghost { background:#fff; color:#111827; border:1px solid #e5e7eb; }
    .btn.primary { background:#111827; color:#fff; }
    .btn.danger { background:#ef4444; color:#fff; }
    .btn.big { padding:12px 14px; font-weight:700; }
    main { flex:1; display:flex; }
    .panel { flex:1; display:none; }
    .panel.active { display:flex; }
    #logsSection { flex-direction:column; }
    .list { padding:12px; display:flex; flex-direction:column; gap:10px; overflow:auto; }
    .card { border:1px solid #e5e7eb; border-radius:12px; padding:10px 12px; display:flex; justify-content:space-between; align-items:flex-start; gap:12px; background:#fff; }
    .card.highlight { outline:3px solid #93c5fd; }
    .meta { font-size:12px; color:var(--muted); }
    #runSection { position:relative; display:none; }
    #runSection.active { display:block; }
    #map { position:absolute; inset:0; }
    .badgewrap { position:fixed; left:8px; right:8px; top:env(safe-area-inset-top,8px); display:flex; gap:8px; z-index:1000; }
    .badge { padding:6px 10px; border-radius:999px; font-weight:600; background:#e2e8f0; }
    .badge.ok { background:var(--okbg); color:var(--ok); }
    .badge.warn { background:var(--warnbg); color:var(--warn); }
    .badge.off { background:var(--offbg); color:var(--off); }
    .dock { position:fixed; right:8px; bottom:8px; display:flex; flex-direction:column; gap:8px; z-index:1000; }
    .toolbar { position:fixed; left:8px; bottom:8px; z-index:1000; display:flex; gap:8px; }
    .toast { position:fixed; left:50%; transform:translateX(-50%); bottom:20px; background:#111827; color:#fff; padding:10px 14px; border-radius:10px; z-index:1100; display:none; }
    .hint { position:fixed; left:8px; bottom:60px; background:#ffffffd8; padding:6px 10px; border-radius:10px; font-size:12px; z-index:999; }
    .auth-card { margin:10px 12px 0; padding:10px 12px; border:1px solid #e5e7eb; border-radius:10px; background:#fff; }
    footer { padding:6px 10px; font-size:12px; color:var(--muted); border-top:1px solid #e5e7eb; }
    @media (max-width:600px) {
      header { flex-direction:column; align-items:flex-start; }
      .dock { flex-direction:column; right:4px; bottom:4px; }
      .toolbar { left:4px; bottom:4px; }
    }
  </style>
</head>
<body>
  <div id="app">
    <header>
      <div style="font-weight:700;">Route MVP</div>
      <div class="tabs">
        <button id="tabLogs" class="tab active" type="button">ログ一覧</button>
        <button id="tabRun" class="tab" type="button">実走する</button>
      </div>
      <div style="display:flex; gap:6px; flex-wrap:wrap;">
        <a id="lnHome" class="btn ghost" href="index.html">公開ルート</a>
        <a id="lnMyPage" class="btn ghost" href="mypage.html">マイページ</a>
      </div>
    </header>

    <div id="authBar" class="auth-card">認証状態を確認中…</div>

    <main>
      <section id="logsSection" class="panel active" aria-label="logs">
        <div id="logsList" class="list">読み込み中…</div>
      </section>
      <section id="runSection" class="panel" aria-label="run">
        <div id="map"></div>
        <div class="badgewrap"><div id="courseBadge" class="badge">準備中…</div></div>
        <div class="dock">
          <button id="startBtn" class="btn primary big" type="button">▶ 記録開始</button>
          <button id="stopBtn" class="btn danger big" type="button">■ 停止</button>
          <button id="followBtn" class="btn ghost" type="button">🔁 追従 OFF</button>
          <button id="locateBtn" class="btn ghost" type="button">📍 現在地だけ</button>
          <button id="backLogsBtn" class="btn ghost" type="button">📄 ログ一覧へ</button>
        </div>
        <div class="toolbar"><button id="editToggleBtn" class="btn ghost" type="button">✏️ 編集モード</button></div>
        <div id="hint" class="hint">▶でGPS+記録+追従ON。■停止で保存確認→保存後はログ一覧へ。</div>
        <div id="toast" class="toast"></div>
      </section>
    </main>

    <footer class="muted">v: <code id="ver"></code></footer>
  </div>

  <script>
    document.getElementById('ver').textContent = window.APP_VERSION;
  </script>
  <script src="https://unpkg.com/@supabase/supabase-js@2/dist/umd/supabase.js"></script>
  <script>
    (function(){
      const supabaseLib = window.supabase;
      const SUPABASE_URL = 'https://cqiqhczxuiyakptdjowr.supabase.co';
      const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNxaXFoY3p4dWl5YWtwdGRqb3dyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTc3NzAwNzMsImV4cCI6MjA3MzM0NjA3M30.vCFQoQnsClINKa5tQAz-rNnF5XLEukmn_Nl0Err5k3k';
      const client = supabaseLib.createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
        auth: { persistSession: true, autoRefreshToken: true, detectSessionInUrl: false }
      });
      window.supabaseClient = client;
      window.supabase = client;
    })();
  </script>

  <!-- ✅ ここから共通化パート -->
  <script src="js/auth-common.js"></script>
  <script>
    AuthCommon.init(window.supabase, { redirectUrl: 'index.html' });
    window.getMyAccountId = () => AuthCommon.getMyAccountId(window.supabase);
  </script>

  <script>
    (function() {
      const version = encodeURIComponent(window.APP_VERSION || '');
      document.write(`<script src="js/storage.js?v=${version}"><\/script>`);
    })();
  </script>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6.5.0/turf.min.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', async () => {
      const supabase = window.supabase;
      const V = () => encodeURIComponent(window.APP_VERSION || '');

      const tabLogs = document.getElementById('tabLogs');
      const tabRun = document.getElementById('tabRun');
      const logsSection = document.getElementById('logsSection');
      const runSection = document.getElementById('runSection');
      const logsList = document.getElementById('logsList');
      const authBar = document.getElementById('authBar');
      const startBtn = document.getElementById('startBtn');
      const stopBtn = document.getElementById('stopBtn');
      const followBtn = document.getElementById('followBtn');
      const locateBtn = document.getElementById('locateBtn');
      const backLogsBtn = document.getElementById('backLogsBtn');
      const editToggleBtn = document.getElementById('editToggleBtn');
      const toastEl = document.getElementById('toast');
      const hintEl = document.getElementById('hint');
      const badgeEl = document.getElementById('courseBadge');
      const lnHome = document.getElementById('lnHome');
      const lnMyPage = document.getElementById('lnMyPage');
      if (lnHome) lnHome.href = `index.html?v=${V()}`;
      if (lnMyPage) lnMyPage.href = `mypage.html?v=${V()}`;

      let map;
      let routePts = [];
      let routeLine;
      let editMode = false;
      let recording = false;
      let follow = false;
      let dot = null;
      let accCircle = null;
      let lastLatLng = null;
      let traced = [];
      let tracedLine = null;
      let lastAddTs = 0;
      let lastSavedLogId = null;
      let isLoggedIn = false;
      let rawTrack = [];

      // 追従ルート＆ラインレイヤ
      let planned = [];        // 予定ルート（{lat,lng}[]）
      let plannedLayer = null; // 予定ライン（青）
      let layerOn = null;      // 実走オンルート（緑）
      let layerOff = null;     // 実走逸脱（赤）

      const ACC_LIMIT = 100;
      const MIN_MOVE = 3;
      const MIN_INTERVAL_MS = 1000;
      const GEO_OPTIONS = { enableHighAccuracy: true, maximumAge: 0, timeout: 20000 };
      const COLORS = {
        planned: '#3b82f6',
        liveOn: '#10b981',
        liveOff: '#ef4444'
      };
      const OFF_THRESHOLD_M = 30;

      const decodePolyline = (str) => {
        try {
          let idx = 0, lat = 0, lng = 0;
          const out = [];
          while (idx < str.length) {
            let b, shift = 0, result = 0;
            do {
              b = str.charCodeAt(idx++) - 63;
              result |= (b & 0x1f) << shift;
              shift += 5;
            } while (b >= 0x20);
            const dlat = (result & 1) ? ~(result >> 1) : (result >> 1);
            shift = 0;
            result = 0;
            do {
              b = str.charCodeAt(idx++) - 63;
              result |= (b & 0x1f) << shift;
              shift += 5;
            } while (b >= 0x20);
            const dlng = (result & 1) ? ~(result >> 1) : (result >> 1);
            lat += dlat;
            lng += dlng;
            out.push({ lat: lat / 1e5, lng: lng / 1e5 });
          }
          return out;
        } catch (e) {
          console.warn('decodePolyline error', e);
          return [];
        }
      };

      const escapeHtml = (str) => (str ?? '').replace(/[&<>"']/g, (c) => ({
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;'
      })[c] || c);
      const fmtDateTime = (v) => v ? new Date(v).toLocaleString() : '-';
      const fmtDistance = (m) => (m ? `${(m / 1000).toFixed(2)} km` : '-');
      const fmtDuration = (sec) => {
        if (!sec && sec !== 0) return '-';
        const h = Math.floor(sec / 3600);
        const m = Math.floor((sec % 3600) / 60);
        const s = sec % 60;
        return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
      };
      const showToast = (msg) => {
        toastEl.textContent = msg;
        toastEl.style.display = 'block';
        setTimeout(() => { toastEl.style.display = 'none'; }, 2000);
      };
      const setBadge = (state, text) => {
        badgeEl.className = `badge ${state || ''}`.trim();
        badgeEl.textContent = text;
      };

      function setTab(tab) {
        const showRun = tab === 'run';
        tabLogs.classList.toggle('active', !showRun);
        tabRun.classList.toggle('active', showRun);
        logsSection.classList.toggle('active', !showRun);
        runSection.classList.toggle('active', showRun);
        logsSection.style.display = showRun ? 'none' : 'flex';
        runSection.style.display = showRun ? 'block' : 'none';
        if (showRun) {
          initMapOnce();
          loadPlannedRouteIfAny();
          clearLiveLayers();
          setTimeout(() => { map && map.invalidateSize(true); }, 120);
        } else {
          clearWatchIfAny();
          recording = false;
          setBadge('', '記録停止');
        }
      }

      async function renderAuthBar() {
        try {
          const { data: { session } } = await supabase.auth.getSession();
          const loginUrl = `login.html?v=${V()}`;
          const myPageUrl = `mypage.html?v=${V()}`;
          if (!session?.user) {
            isLoggedIn = false;
            authBar.innerHTML = `
              未ログインです。ログを保存するには <a class="btn ghost" href="${loginUrl}">ログイン</a> してください。
            `;
            startBtn.disabled = true;
            stopBtn.disabled = true;
        } else {
          isLoggedIn = true;
          const email = session.user.email || '';
          authBar.innerHTML = `
            ログイン中: <strong>${escapeHtml(email)}</strong>
            <div style="margin-top:6px; display:flex; gap:6px; flex-wrap:wrap;">
              <a class="btn ghost" href="${myPageUrl}">マイページへ</a>
              <button class="btn ghost" data-signout type="button">サインアウト</button>
            </div>
          `;
          startBtn.disabled = false;
          stopBtn.disabled = false;
        }
      } catch (e) {
        console.error('renderAuthBar error', e);
        authBar.textContent = '認証状態の取得に失敗しました';
      }
      }

      async function renderLogs() {
        logsList.textContent = '読み込み中…';
        try {
          const logs = await window.dbGetAll('logs');
          if (!logs || logs.length === 0) {
            logsList.innerHTML = '<div class="meta">保存された実走ログはまだありません。記録開始ボタンから実走を記録してください。</div>';
            return;
          }
          logsList.innerHTML = '';
          for (const log of logs) {
            const card = document.createElement('div');
            card.className = 'card';
          if (lastSavedLogId && log.id === lastSavedLogId) {
            card.classList.add('highlight');
            setTimeout(() => {
              card.classList.remove('highlight');
              lastSavedLogId = null;
            }, 2500);
            }
            card.innerHTML = `
              <div style="flex:1 1 auto;">
                <div style="font-weight:600;">${escapeHtml(log.name || '(無題ログ)')} <span class="meta">#${log.id}</span></div>
                <div class="meta">${fmtDateTime(log.startedAt)} → ${fmtDateTime(log.endedAt)}</div>
                <div class="meta">${fmtDistance(log.distanceMeters)} / ${fmtDuration(log.durationSec)}</div>
              </div>
              <div style="display:flex; gap:6px; flex-wrap:wrap;">
                <a class="btn ghost" href="detail.html?id=${encodeURIComponent(log.id)}&kind=run&v=${V()}">詳細</a>
                <button class="btn danger" data-del="${log.id}" type="button">削除</button>
              </div>
            `;
            logsList.appendChild(card);
          }
          logsList.querySelectorAll('button[data-del]').forEach((btn) => {
            btn.onclick = async () => {
              const id = Number(btn.getAttribute('data-del'));
              if (!Number.isFinite(id)) return;
              if (!confirm('この実走ログを削除しますか？')) return;
              try {
                await window.dbDelete('logs', id);
                showToast('削除しました');
              } catch (e) {
                console.error('delete log error', e);
                alert('削除に失敗しました');
              } finally {
                await renderLogs();
              }
            };
          });
        } catch (e) {
          console.error('renderLogs error', e);
          logsList.textContent = 'ログの読み込みに失敗しました';
        }
      }

      let _watchId = null;

      const clearWatchIfAny = () => {
        if (_watchId != null) {
          navigator.geolocation.clearWatch(_watchId);
          _watchId = null;
        }
      };

      function initMapOnce() {
        if (map) return;
        map = L.map('map').setView([35.681236, 139.767125], 14);
        L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
          maxZoom: 19,
          attribution: '&copy; OpenStreetMap contributors'
        }).addTo(map);
        routeLine = L.polyline(routePts, { color: '#2563eb', weight: 4 }).addTo(map);
        ensureLiveLayers();
        setBadge('', '✏️でルート編集、▶で記録開始');
        map.on('click', (e) => {
          if (!editMode || recording) return;
          routePts.push([e.latlng.lat, e.latlng.lng]);
          routeLine.setLatLngs(routePts);
          if (routePts.length > 1) {
            map.fitBounds(routeLine.getBounds(), { padding: [24, 24] });
          }
          if (lastLatLng) updateCourseStatus(lastLatLng);
        });
        loadPlannedRouteIfAny();
      }

      let plannedRouteLoaded = false;
      const initialRouteId = (() => {
        const val = new URL(location.href).searchParams.get('route');
        if (val == null) return null;
        const num = Number(val);
        return Number.isFinite(num) ? num : null;
      })();

      async function loadPlannedRouteIfAny(force = false) {
        if (!map) return;
        try {
          const rid = initialRouteId;
          if (!rid) {
            planned = [];
            if (plannedLayer) {
              plannedLayer.remove();
              plannedLayer = null;
            }
            plannedRouteLoaded = false;
            return;
          }
          if (plannedRouteLoaded && !force) return;
          const { data: route, error } = await supabase
            .from('routes')
            .select('*')
            .eq('id', rid)
            .maybeSingle();
          if (error || !route) return;

          const pts = extractLatLngsFromRoute(route);
          if (!pts.length) return;
          planned = pts;
          plannedRouteLoaded = true;

          if (plannedLayer) {
            plannedLayer.remove();
            plannedLayer = null;
          }
          plannedLayer = L.polyline(planned.map(p => [p.lat, p.lng]), { color: COLORS.planned, weight: 5 }).addTo(map);
          plannedLayer.bringToBack();
          ensureLiveLayers();
          layerOn.bringToFront();
          layerOff.bringToFront();
          map.fitBounds(plannedLayer.getBounds(), { padding: [24, 24], maxZoom: 16 });
          setBadge('', '予定ルート読込済み（青）／▶で記録開始');
        } catch (e) {
          console.warn('loadPlannedRouteIfAny', e);
        }
      }

      function extractLatLngsFromRoute(route) {
        try {
          if (route.geojson) {
            const g = typeof route.geojson === 'string' ? JSON.parse(route.geojson) : route.geojson;
            const out = [];
            const walk = (geom) => {
              if (!geom) return;
              const t = geom.type;
              const co = geom.coordinates;
              if (t === 'LineString') co.forEach(([lng, lat]) => out.push({ lat, lng }));
              else if (t === 'MultiLineString') co.forEach(line => line.forEach(([lng, lat]) => out.push({ lat, lng })));
              else if (t === 'GeometryCollection') (geom.geometries || []).forEach(walk);
            };
            if (g.type === 'Feature') walk(g.geometry);
            else if (g.type === 'FeatureCollection') (g.features || []).forEach(f => walk(f.geometry));
            else walk(g);
            if (out.length) return out;
          }
        } catch (e) {
          console.warn('extractLatLngsFromRoute geojson', e);
        }
        if (route.polyline) {
          return decodePolyline(route.polyline);
        }
        return [];
      }

      function currentFollowLineLatLngs() {
        if (planned && planned.length >= 2) return planned.map(p => [p.lat, p.lng]);
        return (routePts && routePts.length >= 2) ? routePts.map(([la, ln]) => [la, ln]) : [];
      }

      function ensureLiveLayers() {
        if (!map) return;
        if (!layerOn) layerOn = L.polyline([], { color: COLORS.liveOn, weight: 5 }).addTo(map);
        if (!layerOff) layerOff = L.polyline([], { color: COLORS.liveOff, weight: 5 }).addTo(map);
      }

      function clearLiveLayers() {
        if (!map) return;
        ensureLiveLayers();
        if (layerOn) {
          layerOn.setLatLngs([]);
          layerOn.bringToFront();
        }
        if (layerOff) {
          layerOff.setLatLngs([]);
          layerOff.bringToFront();
        }
      }

      const cleanupRun = () => {
        try { clearWatchIfAny(); } catch (_) {}
        try { clearLiveLayers(); } catch (_) {}
        recording = false;
        traced = [];
        lastAddTs = 0;
        plannedRouteLoaded = false;
        rawTrack = [];
      };

      const m2deg = (m) => m / 111320;
      const encodePolyline = (latlngs) => {
        try {
          let lastLat = 0;
          let lastLng = 0;
          let res = '';
          for (const [lat, lng] of latlngs) {
            let iLat = Math.round(lat * 1e5);
            let iLng = Math.round(lng * 1e5);
            let dLat = iLat - lastLat;
            let dLng = iLng - lastLng;
            for (let v of [dLat, dLng]) {
              v = v < 0 ? ~(v << 1) : v << 1;
              while (v >= 0x20) {
                res += String.fromCharCode((0x20 | (v & 0x1f)) + 63);
                v >>= 5;
              }
              res += String.fromCharCode(v + 63);
            }
            lastLat = iLat;
            lastLng = iLng;
          }
          return res;
        } catch (e) {
          console.error('encodePolyline error', e);
          return '';
        }
      };
      const movingAverage = (latlngs) => {
        if (latlngs.length < 3) return latlngs.slice();
        const out = latlngs.map((p) => p.slice());
        for (let i = 1; i < latlngs.length - 1; i++) {
          out[i][0] = (latlngs[i - 1][0] + latlngs[i][0] + latlngs[i + 1][0]) / 3;
          out[i][1] = (latlngs[i - 1][1] + latlngs[i][1] + latlngs[i + 1][1]) / 3;
        }
        return out;
      };
      const dedupeTinyMoves = (latlngs) => {
        if (latlngs.length < 2) return latlngs.slice();
        const out = [latlngs[0]];
        for (let i = 1; i < latlngs.length; i++) {
          const a = L.latLng(out[out.length - 1][0], out[out.length - 1][1]);
          const b = L.latLng(latlngs[i][0], latlngs[i][1]);
          if (a.distanceTo(b) >= 2) out.push(latlngs[i]);
        }
        return out;
      };
      const resampleByDistance = (latlngs, stepMeters) => {
        if (latlngs.length < 2) return latlngs.slice();
        const ls = turf.lineString(latlngs.map(([la, ln]) => [ln, la]));
        const lenKm = turf.length(ls, { units: 'kilometers' });
        const stepKm = stepMeters / 1000;
        const pts = [];
        for (let d = 0; d <= lenKm; d += stepKm) {
          const p = turf.along(ls, d, { units: 'kilometers' });
          const [lng, lat] = p.geometry.coordinates;
          pts.push([lat, lng]);
        }
        return pts.length ? pts : latlngs.slice();
      };

const updateCourseStatus = (latlng) => {
  const ref = currentFollowLineLatLngs();
  if (!ref.length) {
    setBadge('', 'ルート未設定');
    return;
  }
  try {
    const point = turf.point([latlng.lng, latlng.lat]);
    const line = turf.lineString(ref.map(([la, ln]) => [ln, la]));
    const d = turf.pointToLineDistance(point, line, { units: 'meters' });
    if (d <= OFF_THRESHOLD_M) setBadge('ok', `ON COURSE（~${Math.round(d)}m）`);
    else if (d <= OFF_THRESHOLD_M * 2) setBadge('warn', `注意：${Math.round(d)}m外`);
    else setBadge('off', `ルート外：${Math.round(d)}m`);
  } catch (e) {
    console.error('updateCourseStatus error', e);
    setBadge('', 'ルート判定エラー');
  }
};

      const resetRunLayers = () => {
        if (!map) return;
        if (tracedLine) {
          map.removeLayer(tracedLine);
          tracedLine = null;
        }
        traced = [];
        lastAddTs = 0;
        recording = false;
        setEditMode(false);
        clearLiveLayers();
        const hasReference = currentFollowLineLatLngs().length >= 2;
        setBadge('', hasReference ? '予定ルート読込済み（青）／▶で記録開始' : '✏️でルート編集、▶で記録開始');
      };

      const setEditMode = (on) => {
        editMode = !!on;
        if (editToggleBtn) {
          editToggleBtn.textContent = editMode ? '✅ 編集終了（ロック）' : '✏️ 編集モード';
        }
        if (hintEl) {
          hintEl.textContent = editMode
            ? 'ルートに沿って地図をタップしてポイントを追加できます。'
            : '▶でGPS+記録+追従ON。■停止で保存確認→保存後はログ一覧へ。';
        }
      };

      const onPos = (pos) => {
        const { latitude: lat, longitude: lng, accuracy: acc } = pos.coords;
        const latlng = L.latLng(lat, lng);
        lastLatLng = latlng;
        ensureLiveLayers();
        if (!dot) {
          dot = L.circleMarker(latlng, { radius: 6, weight: 2, color: '#2563eb', fillColor: '#3b82f6', fillOpacity: 1 }).addTo(map);
          accCircle = L.circle(latlng, { radius: acc, color: '#93c5fd', weight: 1, fillColor: '#bfdbfe', fillOpacity: 0.25 }).addTo(map);
        } else {
          dot.setLatLng(latlng);
          accCircle.setLatLng(latlng).setRadius(acc);
        }
        if (follow) map.panTo(latlng, { animate: true });

        const now = Date.now();
        if (recording && acc <= ACC_LIMIT && (now - lastAddTs) >= MIN_INTERVAL_MS) {
          const prev = traced[traced.length - 1];
          const moved = !prev || latlng.distanceTo(L.latLng(prev[0], prev[1])) >= MIN_MOVE;
          if (moved) {
            traced.push([lat, lng]);
            rawTrack.push({ lat, lng, acc, ts: now });
            lastAddTs = now;
            appendLivePoint(lat, lng);
          }
        }
        updateCourseStatus(latlng);
      };

function appendLivePoint(lat, lng) {
  ensureLiveLayers();
  let isOn = true;
  const ref = currentFollowLineLatLngs();
  if (ref.length >= 2) {
          try {
            const point = turf.point([lng, lat]);
            const line = turf.lineString(ref.map(([la, ln]) => [ln, la]));
            const d = turf.pointToLineDistance(point, line, { units: 'meters' });
            isOn = d <= OFF_THRESHOLD_M;
          } catch (e) {
            console.warn('appendLivePoint distance error', e);
          }
        }
        if (isOn) layerOn.addLatLng([lat, lng]);
        else layerOff.addLatLng([lat, lng]);
        layerOn.bringToFront();
  layerOff.bringToFront();
}

function ensureLineMin2(pts) {
  if (!Array.isArray(pts) || pts.length === 0) return [];
  if (pts.length >= 2) return pts;
  const p = pts[0];
  return [p, { lat: p.lat, lng: p.lng, ts: (p.ts || Date.now()) + 1, acc: p.acc || 0 }];
}

      const onErr = (err) => {
        console.warn('geolocation error', err);
        showToast('位置情報エラー');
        clearWatchIfAny();
      };

      startBtn.onclick = () => {
        if (!isLoggedIn) {
          alert('ログイン後に記録できます。先にログインしてください。');
          return;
        }
        if (!('geolocation' in navigator)) {
          alert('この端末では位置情報が使えません');
          return;
        }
        follow = true;
        followBtn.textContent = '🔁 追従 ON';
        clearWatchIfAny();
        _watchId = navigator.geolocation.watchPosition(onPos, onErr, GEO_OPTIONS);

        setEditMode(false);
        recording = true;
        traced = [];
        lastAddTs = 0;
        rawTrack = [];
        if (tracedLine) {
          map.removeLayer(tracedLine);
          tracedLine = null;
        }
        clearLiveLayers();
        window.__logStartedAt = new Date().toISOString();
        setBadge('warn', '記録中：オンコース判定有効');
        showToast('記録を開始しました');
      };

      stopBtn.onclick = async () => {
        if (!recording) {
          showToast('記録は開始されていません');
          return;
        }
        recording = false;
        clearWatchIfAny();

        const count = traced.length;
        const ok = confirm(`記録を停止します。ログを保存しますか？（ポイント数: ${count}）`);
        if (!ok) {
          setBadge('', '記録停止');
          showToast('保存せず終了');
          window.__logStartedAt = null;
          return;
        }

        const accountId = await (window.getMyAccountId ? window.getMyAccountId() : null);
        if (!accountId) {
          alert('ログインが切れました。再ログインしてください');
          window.__logStartedAt = null;
          location.replace('index.html?v=' + encodeURIComponent(window.APP_VERSION || ''));
          return;
        }

        const raw = rawTrack.length ? rawTrack : traced.map(([la, ln]) => ({ lat: la, lng: ln, ts: Date.now(), acc: 0 }));
        const linePts = ensureLineMin2(raw);
        if (linePts.length < 2) {
          alert('位置が取得できませんでした。');
          window.__logStartedAt = null;
          return;
        }

        let distance_m = 0;
        for (let i = 1; i < linePts.length; i++) {
          const a = linePts[i - 1];
          const b = linePts[i];
          distance_m += (a.lat === b.lat && a.lng === b.lng) ? 0 : haversine(a, b);
        }
        distance_m = Math.round(distance_m);

        const startTs = linePts[0].ts || Date.now();
        const endTs = linePts[linePts.length - 1].ts || Date.now();
        const durationSec = Math.max(1, ((endTs - startTs) / 1000) | 0);

        const coords = linePts.map(p => [p.lng, p.lat]);
        const gj = { type: 'LineString', coordinates: coords };

        const today = new Date();
        const nameDefault = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')} 実走`;
        const name = prompt('実走ログの名前を入力してください', nameDefault) || nameDefault;

        const record = {
          accountId,
          name,
          startedAt: new Date(startTs).toISOString(),
          endedAt: new Date(endTs).toISOString(),
          polyline: encodePolyline(linePts.map(p => [p.lat, p.lng])),
          geojson: gj,
          pointCount: linePts.length,
          distanceMeters: distance_m,
          durationSec,
          bbox: null,
          routeId: planned && planned.length && initialRouteId ? initialRouteId : null
        };

        let redirected = false;
        try {
          console.log('実走ログを保存します', record);
          const saved = await window.dbPut('logs', record);
          if (saved?.id) {
            location.href = `detail.html?id=${encodeURIComponent(saved.id)}&kind=run&v=${V()}`;
            redirected = true;
            return;
          }
          lastSavedLogId = saved?.id ?? null;
          showToast('保存しました');
        } catch (e) {
          console.error('RUN SAVE ERROR', e, record);
          alert('保存に失敗: ' + (e?.message || '不明なエラー'));
          window.__logStartedAt = null;
          return;
        } finally {
          window.__logStartedAt = null;
          if (!redirected) {
            await renderLogs();
            setTab('logs');
          }
        }
      };

      followBtn.onclick = () => {
        follow = !follow;
        followBtn.textContent = follow ? '🔁 追従 ON' : '🔁 追従 OFF';
      };

      locateBtn.onclick = () => {
        if (!('geolocation' in navigator)) {
          alert('この端末では位置情報が使えません');
          return;
        }
        clearWatchIfAny();
        follow = true;
        followBtn.textContent = '🔁 追従 ON';
        _watchId = navigator.geolocation.watchPosition(onPos, onErr, GEO_OPTIONS);
      };

      editToggleBtn.onclick = () => {
        if (recording) {
          alert('記録中は編集できません');
          return;
        }
        setEditMode(!editMode);
      };

      backLogsBtn.onclick = () => {
        setTab('logs');
      };

      tabLogs.onclick = () => setTab('logs');
      tabRun.onclick = () => {
        setTab('run');
        resetRunLayers();
      };

      const safeRender = async () => {
        try {
          await renderAuthBar();
        } catch (e) {
          console.error('renderAuthBar failure', e);
          if (authBar) authBar.textContent = '認証状態の取得に失敗しました';
        }
        try {
          await renderLogs();
        } catch (e) {
          console.error('renderLogs failure', e);
          if (logsList) logsList.textContent = 'ログの読み込みに失敗しました';
        }
      };

      await safeRender();

      supabase.auth.onAuthStateChange(async (_event, session) => {
        await safeRender();
        if (session?.user) {
          plannedRouteLoaded = false;
          await loadPlannedRouteIfAny(true);
        }
      });
      window.addEventListener('pageshow', async () => {
        try {
          await safeRender();
          if (map) {
            plannedRouteLoaded = false;
            await loadPlannedRouteIfAny(true);
          }
        } catch (e) {
          console.warn('pageshow refresh error', e);
        }
      });
      window.addEventListener('pagehide', cleanupRun, { passive: true });
      window.addEventListener('beforeunload', cleanupRun);

      setTab('logs');
    });
  </script>
  <script>
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register(`./service-worker.js?v=${encodeURIComponent(window.APP_VERSION || '')}`)
        .catch(err => console.error('SW register failed', err));
    }
  </script>
</body>
</html>
